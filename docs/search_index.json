[["index.html", "Fall 2020 EDAV Community Contributions Chapter 1 Instructions 1.1 Background 1.2 Preparing your .Rmd file 1.3 Submission steps 1.4 Optional tweaks 1.5 FAQ", " Fall 2020 EDAV Community Contributions 2020-11-16 Chapter 1 Instructions This chapter gives you all the information you need to upload your community contribution. Please read this entire document carefully before making your submission. Of particular note is the fact that bookdown requires a different .Rmd format than you’re used to, so you must make changes to the beginning of the file as described below before submitting. 1.1 Background This web site makes use of the bookdown package to render a collection of .Rmd files into a nicely formatted online book with chapters and subchapters. Your job will be to submit a slightly modified version of your community contribution .Rmd file to the GitHub repository where the source files for this web site are stored. On the backend, the admins will divide the chapters into book sections and order them. If your community contribution is in a different format, then create a short .Rmd file that explains what you did, and includes links to any relevant files, such as slides, etc. which you can post on your GitHub repo (or another online site.) 1.2 Preparing your .Rmd file You should only submit ONE Rmd file. After completing these modifications, your .Rmd should look like this sample .Rmd. Create a concise, descriptive name for your project. For instance, name it base_r_ggplot_graph or something similar if your work is about contrasting/working with base R graphics and ggplot2 graphics. Check the .Rmd filenames in the project repo to make sure your name isn’t already taken. Your project name should be words only and joined with underscores, no white space. In addition, all letters must be lowercase. Create a copy of your .Rmd file with the new name. Completely delete the YAML header (the section at the top of the .Rmd that includes name, title, date, output, etc.) including the --- line. Choose a short, descriptive, human readable title for your project as your title will show up in the table of contents – look at examples in the 2019 EDAV rendered book of community contributions https://jtr13.github.io/cc19. Capitalize the first letter only (“sentence case”). On the first line of your document, enter a single hashtag, followed by a single whitespace, and then your title. It is important to follow this format so that bookdown renders your title as a header. Do not use single # headers anywhere else in the document. Note: if your chapter is the first in a section, a second # header and section description will be requested during the pull-request and merge phase. The second line should be blank, followed by your name(s): # Base R vs. ggplot2 Aaron Burr and Alexander Hamilton Your content starts here. If your project requires data, please use a built-in dataset or read directly from a URL, such as: df &lt;- readr::read_csv(\"https://people.sc.fsu.edu/~jburkardt/data/csv/addresses.csv\") If you absolutely must include a data file, please use a small one, as for many reasons it is desirable to keep the repository size as small as possible. If you have included a setup chunk in your Rmd file, please remember to remove the label setup in the chunk, i.e., use: {r, include=FALSE} instead of: {r setup, include=FALSE} If your project requires libraries to be installed and included in the document, please adhere to the following conventions. Do not evaluate any install.packages() statements in your document. Consumers of an Rmd file won’t want packages to get installed when they knit your document. Include any library() statements at the top of your Rmd file, below the title, name, and setup, but above any content. If your chapter requires the installation of a package from source (is a GitHub installation), please add a comment identifying it as such. Here is an example library() section with install statements that won’t be evaluated: install.packages(&quot;devtools&quot;) # used for installation from source install.packages(&quot;dplyr&quot;) install.packages(&quot;ggplot2&quot;) library(&quot;devtools&quot;) devtools::install_github(&quot;twitter/AnomalyDetection&quot;) library(&quot;AnomalyDetection&quot;) # must be installed from source library(&quot;dplyr&quot;) library(&quot;ggplot2&quot;) You could include both sections, or you could just include the second library() section and trust R users to install any packages themselves. If you developed your Rmd file before moving your library() statements above the rest of the file content, it is highly recommended to knit and review your document again. This may change the namespace that was available in each section of your code during development, causing a function not to work or to exhibit unexpected behavior. This common issue is mentioned in the EDAV R Basics “Functions stop working” section. Want to get fancy? See the optional tweaks section below. 1.3 Submission steps To submit your work, we will be following “Workflow #4” – that is submitting a pull request to someone else’s repository to which you do not have write access. Instructions are available in this tutorial. They are repeated below in abbreviated form, with specific instructions on naming conventions, content information, and other important details. Fork cc20 repo (this repo) to your GitHub account. Clone/download the forked repo to your local computer. Create a new branch and name it with your project name, in our case sample_project. Do not skip this step. We will not merge your PR if it doesn’t come from a branch. If you already forgot to do this, check this tutorial for how to fix it. Copy your modified .Rmd file with the same name into the root directory on the branch. In our example, it is sample_project.Rmd. Do not include an .html file. (In order for the bookdown package to work, all .Rmd files will be rendered behind the scenes.) [OPTIONAL] If you have other resources (such as images) included in your project, create a folder under resources/. In our example, it is resources/sample_project/. Put the resources files there. Be sure to change all the links in your .Rmd to include resources/.../, for example: ![Test Photo](resources/sample_project/election.jpg) When you are ready to submit your project, push your branch to your remote repo. Follow this tutorial to create a pull request. At this point a back and forth will begin with the team managing the pull requests. If you are asked to make changes, simply make the changes on your local branch, save, commit, and push to GitHub. The new commits will be added to your pull request; you do not need to, and should not, create a new pull request. (If, based on the circumstances, it does make sense to close the pull request and start a new one, we will tell you.) Once your pull request is merged, it’s fine to delete your local clone (folder) as well as the forked repository in your GitHub account. 1.4 Optional tweaks If you prefer for links from your chapter to open in new tabs, add {target=\"_blank\"} after the link, such as: [edav.info](edav.info){target=\"_blank\"} Note that your headers (##, ###, etc.) will be converted to numbered headings as such: ## –&gt; 3.1 ### –&gt; 3.1.1 These headings will appear as chapter subheadings and sub-subheadings in the navigation panel on the left. Think about a logical structure for users to navigate your chapter. We recommend using only ## and ### headings since “sub-sub-subheadings” such as 4.1.3.4 are generally unnecessary and look messy. Unfortunately, there’s no simple way to preview your chapter before it’s actually merged into the project. (bookdown has preview_chapter() option but it only works after the entire book has been rendered at least once and that will become more and more complex and require more and more packages as the project grows.) If you really want to preview it, fork and clone this minimal bookdown repo, add your .Rmd file, click the “Build book” button on the Build tab (next to Git), and then open any of the .html files in the _book folder in a web browser to see the rendered book. (Do not click the Knit button as it will not build a bookdown book.) If you’re interested in more bookdown options, see the official reference book. Have more useful tweaks to share? Submit an issue or PR. 1.5 FAQ 1.5.1 What should I expect after creating a pull request? Within a week after you create a pull request, we will apply a label to it and assign an administrator who will review all the files you submit to see if they meet the requirements. It will take some time before we can process all the pull requests, so as long as you see your pull request has been labeled and assigned to an admin, don’t worry. However, if the admin contacts you regarding the pull request, that usually means your files fail to meet some requirements. The admin will clearly state what is wrong, so please fix them as soon as possible. 1.5.2 What if I catch mistakes after my pull request is merged? You may submit additional pull requests to fix material on the site. If the edits are small, such as fixing typos, it is easiest to make the edits directly on GitHub, following these instructions. We will merge first pull requests before edits, so please be patient. 1.5.3 Other questions If you encounter other problems, please submit an issue and we will look into it. Thank you for your contributions! "],["sample-project.html", "Chapter 2 Sample project", " Chapter 2 Sample project Joe Biden and Donald Trump This chapter gives a sample layout of your Rmd file. Test Photo "],["customized-plot-matrix-pairs-and-ggpairs.html", "Chapter 3 Customized Plot Matrix: pairs and ggpairs 3.1 Overview: Things we can do with pairs() and ggpairs() 3.2 Scatterplot matrix for continuous variables 3.3 Categorical variables 3.4 Outside sources", " Chapter 3 Customized Plot Matrix: pairs and ggpairs Yibai Liu library(GGally) library(ggplot2) library(vcd) 3.1 Overview: Things we can do with pairs() and ggpairs() When our data contains multivariate variables, it is important to evaluate associations between these variables before modeling. We can create scatterplot matrices, correlation matrix, as well as mosaic pairs plots to get an idea about if and how these variables are correlated with each other. In this tutorial, I would plot using a base r function pairs() and a function ggpairs() from the GGally package, which both functions provide methods to generate customized plot matrices. Plots for different purposes: - Scatterplot matrix: correlations between continuous variables - Mosaic pairs plot: correlations between categorical variables 3.2 Scatterplot matrix for continuous variables 3.2.1 Plot with pairs() 3.2.1.1 Basic scatterplot matrix of the `mtcars dataset (all numeric variables) data(mtcars) pairs(~., data = mtcars, main = &quot;Scatterplot Matrix of `mtcars`&quot;) We notice that there are some numeric variables actually discrete or representing categories, so we can trim all discrete and categorical variables, and only plot continuous variables in the matrix. 3.2.1.2 Continuous variables only pairs(mtcars[, c(1,3:7)], main = &quot;Scatterplot Matrix of `mtcars`&quot;) 3.2.1.3 Change color, shape, size of points, as well as labels and gaps of the plot pairs(mtcars[, c(1,3:7)], col = &quot;blue&quot;, # Change color pch = 19, # Change shape of points cex = 0.8, # Change size of points labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), # Change labels gap = 0.3, # Change gaps in between main = &quot;Scatterplot Matrix of `mtcars`&quot;) 3.2.1.4 Add a smoother to each scatterplot pairs(mtcars[, c(1,3:7)], lower.panel = panel.smooth, # Add a smoother for the lower panel col = &quot;blue&quot;, pch = 19, cex = 0.8, labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), gap = 0.3, main = &quot;Scatterplot Matrix of `mtcars`&quot;) 3.2.1.5 Separate groups using different colors Tip: You can also highlight a certain level of a categorical variable by simply turn other levels to grey. mtcars$vs &lt;- as.factor(mtcars$vs) pairs(mtcars[, c(1,3:7)], col = c(&quot;blue&quot;,&quot;red&quot;)[mtcars$vs], # Group by variable `vs` pch = 19, cex = 0.8, labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), gap = 0.3, main = &quot;Scatterplot Matrix of `mtcars` Grouped by Engine&quot;) By separating data points by vs or the engine type, we can see that two groups form distinct clusters for many of the variables. 3.2.1.6 Choose panel display If the plot seems dominated by too many points, you can turn off one of the panels. pairs(mtcars[, c(1,3:7)], col = c(&quot;blue&quot;,&quot;red&quot;)[mtcars$vs], pch = 19, cex = 0.8, labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), gap = 0.3, upper.panel = NULL, # Turn off the upper panel above the diagonal main = &quot;Scatterplot Matrix of `mtcars`&quot;) 3.2.1.7 Customize your own plot matrix The plot matrix is consisted of multiple panels, e.g. the upper panel, lower panel, diagonal panel, etc. You can customize each panel and make your own plot. #Panel of correlations panel.corr &lt;- function(x, y){ usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) par(usr = c(0, 1, 0, 1)) r &lt;- round(cor(x, y), digits=3) txt &lt;- paste0(&quot;Corr: &quot;, r) text(0.5, 0.5, txt, cex = 1) } #Panel of histograms panel.hist &lt;- function(x, ...){ usr &lt;- par(&quot;usr&quot;); on.exit(par(usr)) par(usr = c(usr[1:2], 0, 1.5) ) h &lt;- hist(x, plot = FALSE) breaks &lt;- h$breaks len &lt;- length(breaks) y &lt;- h$counts/max(h$counts) rect(breaks[-len], 0, breaks[-1], y, col = &quot;lightblue&quot;) } #Panel of scatterplots panel.scat &lt;- function(x, y){ points(x,y, pch = 19, cex = 1, col = &quot;coral&quot;) } #Plot pairs(mtcars[, c(1,3:7)], lower.panel = panel.scat, upper.panel = panel.corr, diag.panel = panel.hist, labels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), gap = 0.3, main = &quot;Scatterplot matrix of `mtcars`&quot;) 3.2.2 Plot with ggpairs() from GGally package 3.2.2.1 Basic ggpairs() plot # You need both ggplot2 and GGally packages loaded to use ggpairs() ggpairs(mtcars[, c(1,3:7)], columnLabels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), upper = list(continuous = wrap(&#39;cor&#39;, size = 4)), title = &quot;Scatterplot matrix of `mtcars`&quot;) 3.2.2.2 Separate groups using different colors ggpairs(mtcars[, c(1,3:7)], columnLabels = c(&quot;Miles&quot;,&quot;Displacement&quot;,&quot;Horsepower&quot;, &quot;Rear axle ratio&quot;,&quot;Weight&quot;,&quot;1/4 mile time&quot;), aes(color = mtcars$vs), # Separate data by levels of vs upper = list(continuous = wrap(&#39;cor&#39;, size = 3)), lower = list(combo = wrap(&quot;facethist&quot;, bins = 30)), diag = list(continuous = wrap(&quot;densityDiag&quot;, alpha = 0.5)), title = &quot;Scatterplot matrix of `mtcars` Grouped by Engine&quot;) 3.3 Categorical variables There are some categorical variables in the dataset mtcars. We can turn these variables and also discrete variables into factors ### Factorize discrete/categorical variables mtcars$cyl &lt;- as.factor(mtcars$cyl) mtcars$am &lt;- as.factor(mtcars$am) mtcars$gear &lt;- as.factor(mtcars$gear) Now we can create a mosaic pairs plot with pairs_diagonal_mosaic() in the vcd package 3.3.1 pairs() plot for categorical variables # You need to load the `vcd` package p &lt;- mtcars[, c(2,8:10)] pairs(table(p), # Here the data needs to be in a table format diag_panel = pairs_diagonal_mosaic(offset_varnames=-2.5)) #move down variable labels 3.3.2 Highlight correlations with shade colors pairs(table(p), diag_panel = pairs_diagonal_mosaic(offset_varnames=-2.5), #move down variable names upper_panel_args = list(shade = TRUE), #set shade colors lower_panel_args = list(shade = TRUE)) 3.4 Outside sources You can check out the following links to find more interesting ways to customize your plot matrix. [R pairs &amp; ggpairs Plot Functions] https://statisticsglobe.com/r-pairs-plot-example/#:~:text=The%20pairs%20R%20function%20returns,pairs%20command%20is%20shown%20above. [ggpairs() r documentation] https://www.rdocumentation.org/packages/GGally/versions/1.5.0/topics/ggpairs [Pairs plot for contingency tables] http://finzi.psych.upenn.edu/R/library/vcd/html/pairs.table.html "],["china-choropleth-map.html", "Chapter 4 China choropleth map 4.1 Overview 4.2 Data Collection 4.3 Static Map with ggplot 4.4 Interactive Map with hchinamap 4.5 Interactive Map with leafletCN 4.6 Conclusion", " Chapter 4 China choropleth map Jialu Xia and Danyang Han library(jsonlite) library(tidyverse) library(hash) library(ggplot2) library(maptools) library(tidyr) library(rgdal) library(here) library(hchinamap) library(magrittr) library(data.table) library(mapproj) library(shadowtext) library(leafletCN) 4.1 Overview From a choropleth map of Covid-19 spread, we could clearly see the number of confirmed cases and severity in each area on the map. We would like to introduce some techniques to plot choropleth map with R. There are different types of maps, like the world map, maps of Continents and maps of Countries etc,. Different maps may require different packages to plot. Here we typically explore maps of China. As a running example, we collected China’s Covid-19 data and start from ggplot, a tool we learned in the lectures. In addition to this, we practiced hchinamap and leafletCN to plot interactive maps. 4.2 Data Collection We web-scarped China’s Covid-19 data. The data set includes daily updates of confirmed cases and death for each city in China. url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;callback=1580373566110&#39; x = readLines(url, encoding=&quot;UTF-8&quot;) x = sub(&quot;^\\\\d+&quot;, &quot;&quot;, x) x = sub(&quot;^\\\\(&quot;, &quot;&quot;, x) x = sub(&quot;\\\\)$&quot;, &quot;&quot;, x) y = fromJSON(x) d = fromJSON(y$data) h = d$areaTree$children[[1]] names_dic = hash(c(&quot;香港&quot;, &quot;上海&quot;, &quot;新疆&quot;, &quot;台湾&quot;, &quot;四川&quot;, &quot;广东&quot;, &quot;陕西&quot;, &quot;福建&quot;, &quot;内蒙古&quot;, &quot;天津&quot;, &quot;河北&quot;, &quot;江苏&quot;, &quot;山东&quot;, &quot;浙江&quot;, &quot;辽宁&quot;, &quot;山西&quot;, &quot;河南&quot;, &quot;重庆&quot;, &quot;云南&quot;, &quot;北京&quot;, &quot;黑龙江&quot;, &quot;湖南&quot;, &quot;广西&quot;, &quot;宁夏&quot;, &quot;吉林&quot;, &quot;西藏&quot;, &quot;海南&quot;, &quot;澳门&quot;, &quot;江西&quot;, &quot;青海&quot;, &quot;湖北&quot;, &quot;甘肃&quot;, &quot;安徽&quot;, &quot;贵州&quot; ), c(&quot;Hongkong&quot;, &quot;Shangahi&quot;, &quot;Xinjiang&quot;, &quot;Taiwan&quot;, &quot;Sichuan&quot;, &quot;Guangdong&quot;,&quot;Shannxi&quot;, &quot;Fujian&quot;, &quot;Inner Mongolia&quot;, &quot;Tianjing&quot;, &quot;Hebei&quot;,&quot;Jiangsu&quot;, &quot;Shandong&quot;, &quot;Zhejiang&quot;, &quot;Liaoning&quot;,&quot;Shanxi&quot;, &quot;Henan&quot;, &quot;Chongqin&quot;, &quot;Yunnan&quot;, &quot;Beijing&quot;,&quot;Heilongjiang&quot;, &quot;Hunan&quot;, &quot;Guangxi&quot;,&quot;Ningxia&quot;,&quot;Jilin&quot;,&quot;Tibet&quot;,&quot;Hainan&quot;, &quot;Macao&quot;, &quot;Jiangxi&quot;,&quot;Qinghai&quot;, &quot;Hubei&quot;, &quot;Gansu&quot;, &quot;Anhui&quot; ,&quot;Guizhou&quot; ) ) name_en = values(names_dic, keys = h$name, USE.NAMES = FALSE) data = data.frame(h$name, name_en, h$total$confirm) #rename column name data&lt;-data %&gt;% rename( province_CH=h.name, province_EN=name_en, total_confirm=h.total.confirm ) data$province_CH=as.factor(data$province_CH) data$province_EN=as.factor(data$province_EN) write.csv(file=&#39;Heatmap_data.csv&#39;,data, fileEncoding = &#39;UTF-8&#39;) head(data) ## province_CH province_EN total_confirm ## 1 香港 Hongkong 5466 ## 2 上海 Shangahi 1277 ## 3 台湾 Taiwan 602 ## 4 四川 Sichuan 786 ## 5 陕西 Shannxi 487 ## 6 广东 Guangdong 1968 The dataset we use here is a 34x3 data frame: province_CH: province name in Chinese province_EN: province name in English total_confirm: total confirmed cases We are gonna plot total confirmed cases. 4.3 Static Map with ggplot Since ggplot does not have build-in China map, we download shape files from the “Capital of Statistics” webiste and prepare the shape data for ggplot. 4.3.1 Prepare the shape data of China dsn&lt;-&quot;resources/china_choropleth_map/china-province-border-data/bou2_4p.shp&quot; layer&lt;-&quot;bou2_4p&quot; china_map &lt;- rgdal::readOGR(dsn=dsn, layer=layer) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/Users/joycerobbins/cc20/resources/china_choropleth_map/china-province-border-data/bou2_4p.shp&quot;, layer: &quot;bou2_4p&quot; ## with 925 features ## It has 7 fields ## Integer64 fields read as strings: BOU2_4M_ BOU2_4M_ID ###Note: we attached external spetial data of china, named &quot;china-province-border-data&quot; and it includes &quot;bou2_4p.shp&quot; ### dsn is the path of &quot;bou2_4p.shp&quot; # extract province information from shap file china_map_data = data.table::setDT(china_map@data) data.table::setnames(china_map_data, &quot;NAME&quot;, &quot;province&quot;) # transform to UTF-8 coding format china_map_data[, province:=iconv(province, from = &quot;GBK&quot;, to = &quot;UTF-8&quot;)] # create id to join province back to lat and long, id = 0 ~ 924 china_map_data[, id:= .I-1] # id = 0, 1, 2, ... , used to match to `dt_china` # there are more shapes for one province due to small islands, extract the provinces that are consistent with our data. china_map_data[, province:= as.factor(province)] china_map_data &lt;- china_map_data[!is.na(province)] china_map_data &lt;- china_map_data[AREA &gt; 0.1] head(china_map_data, 3) ## AREA PERIMETER BOU2_4M_ BOU2_4M_ID ADCODE93 ADCODE99 province id ## 1: 54.447 68.489 2 23 230000 230000 黑龙江省 0 ## 2: 129.113 129.933 3 15 150000 150000 内蒙古自治区 1 ## 3: 175.591 84.905 4 65 650000 650000 新疆维吾尔自治区 2 dt_china = setDT(fortify(china_map)) head(dt_china, 3) ## long lat order hole piece id group ## 1: 121.4884 53.33265 1 FALSE 1 0 0.1 ## 2: 121.4995 53.33601 2 FALSE 1 0 0.1 ## 3: 121.5184 53.33919 3 FALSE 1 0 0.1 dt_china[, id:= as.numeric(id)] setkey(china_map_data, id) setkey(dt_china, id) dt_china &lt;- china_map_data[dt_china] ##adjust province names in the order of levels(china_map_data$province) so that they are compatible with plotting function re_level &lt;- function(levels){ re_level = c() for (i in 1:33) { pro = levels[i] if (grepl(&quot;黑&quot;, pro)) pro = substr(pro, start = 1, stop = 3) else if (grepl(&quot;内&quot;, pro)) pro = substr(pro, start = 1, stop = 3) else pro = substr(pro, start = 1, stop = 2) re_level[i] = pro } re_level &lt;- as.character(re_level) return(re_level) } get.centroids &lt;- function( data = dt1, long = &quot;long&quot;, lat = &quot;lat&quot;, by_var = &quot;state&quot;, # the grouping variable, e.g. state: get centroid by state fill_var = NULL # the variable to plot ){ data &lt;- data[!is.na(data[[by_var]]),] data[[by_var]] &lt;- as.character(data[[by_var]]) # sometimes there is empty factor level dt1_df &lt;- sp::SpatialPointsDataFrame(coords = data[, c(long, lat), with = FALSE], data = data) dt1_geo &lt;- by(dt1_df, dt1_df[[by_var]], function(x) {sp::Polygon(x[c(long, lat)])@labpt}) centroids &lt;- stats::setNames(do.call(&quot;rbind.data.frame&quot;, dt1_geo), c(long, lat)) centroids$name &lt;- names(dt1_geo) if(!is.null(fill_var)){ # if need to join fill value setkeyv(setDT(centroids), &quot;name&quot;) dt_var &lt;- unique(data[,c(by_var, fill_var), with = FALSE]) setkeyv(dt_var, by_var) centroids &lt;- dt_var[centroids] } return(centroids) } # combine our covid data with the shape data input_data&lt;-data %&gt;% filter(province_EN!=&quot;Macao&quot;) input_data&lt;-data.table(input_data) levels(dt_china$province) &lt;- re_level(levels(china_map_data$province)) # relevel dt_china so that it matches the level of shape file. setkey(input_data, province_CH) setkey(dt_china, province) dt_china &lt;- input_data[dt_china, nomatch = 0] centroids_cn &lt;- get.centroids(data = dt_china, by_var = &quot;province_CH&quot;) centroids_en &lt;- get.centroids(data = dt_china, by_var = &quot;province_EN&quot;) 4.3.2 Plot: gg_en &lt;- ggplot(dt_china, aes(x = long, y = lat, group = group, fill = total_confirm)) + labs(fill = &quot;Number of Confirm&quot;)+ geom_polygon()+ scale_fill_gradientn(colours = RColorBrewer::brewer.pal(8, &quot;GnBu&quot;), na.value = &quot;grey90&quot;, guide = guide_colourbar(barwidth = 25, barheight = 0.4, #put legend title on top of legend title.position = &quot;top&quot;)) + labs(fill = &quot;Number of Confirm&quot;, x = &quot;Longitude&quot;, y = &quot;Latitude&quot;) + coord_map() + # map scale theme_void() + theme(legend.position = &quot;bottom&quot;, legend.title=element_text(size=12), # font size of the legend legend.text=element_text(size=10)) # add province name to the map gg_en+geom_text(data = centroids_en, aes(x = long, y = lat, label = name), inherit.aes = FALSE) This method is tedious as we need to deal with the shape data, and we could not see number of confirmed cases directly from the plot. So we introduce other two packages which are simpler and more interactive in the following parts. 4.4 Interactive Map with hchinamap The package hchinamap that allows interactive map plots and contains map with complete Chinese territory. hchinamap(name=data$province_CH, value=data$total_confirm, width=&quot;100%&quot;, height=&quot;400px&quot;, title=&quot;Covid map of China&quot;, region=&quot;China&quot;, minColor = &quot;#f1eef6&quot;, maxColor = &quot;#980043&quot;, itermName = &quot;Total confirmed&quot;, hoverColor = &quot;#f6acf5&quot;, ) Here, the map shows total confirmed cases in each province in China. One of the shortage of this package is that we can only use color to represent numeric values (number of confirmed cases in this plot). So, in this case, it is hard to tell from the color the relative confirmed cases in each province because the vast majority of the cases are concentrated in Hubei province, and other provinces have only relatively minimal confirmed cases. We can see that the map showing dark color in only Hubei province and merely white in all other provinces. An advantage is that we can also plot maps for provinces using this package. Take Hubei province for example, from the web-scraped data set, we created a data frame that contains total confirmed cases in each city in Hubei province. idx = match(&quot;湖北&quot;, h$name) hubei = h$children hubeidata&lt;-hubei[[idx]] write.csv(file=&#39;Hubei_data.csv&#39;,hubeidata, fileEncoding = &#39;UTF-8&#39;) hchinamap(name = hubeidata$name, value = hubeidata$total$confirm, width = &quot;100%&quot;, height = &quot;400px&quot;, title = &quot;Covid Map of Hubei&quot;, region = &quot;Hubei&quot;, minColor = &quot;#f1eef6&quot;, maxColor = &quot;#980043&quot;, itermName = &quot;Total confirmed&quot;, hoverColor = &quot;#f6acf5&quot;) 4.5 Interactive Map with leafletCN The package leafletCN provides four color methods: numeric, bin, quantile and factor. Coloring by quantile allows us to see how many cases each province have relative to other provinces, which solved the problem we have with hchinamap. And another good thing is that we could customize the content displayed on the area when clicked, so we could display the exact number of confirmed cases! geojsonMap(dat = data, mapName = &quot;china&quot;, namevar = ~ province_CH, valuevar = ~ total_confirm, popup = paste0(data$province_CH,data$province_EN,&quot;:&quot;,data$total_confirm), palette = &quot;Reds&quot;, legendTitle = &quot;Quantile of confirmed number&quot;, colorMethod=&quot;quantile&quot;) 4.6 Conclusion Other data could also be plot on the maps with the packages we introduced above, like population and temperature. Based on the feature of different datasets, you can try all packages and chose the most suitable one! Reference: https://liuyanguu.github.io/post/2020/06/12/ggplot-us-state-and-china-province-heatmap/ "],["chinese-translation-of-candela-package.html", "Chapter 5 Chinese Translation of Candela Package 5.1 Candela 5.2 Candela 包使用 5.3 组件 5.4 API文件 5.5 开发人员文件", " Chapter 5 Chinese Translation of Candela Package Wenjie Zhu and Jin Qian library(candela) Source File：https://readthedocs.org/projects/candela/downloads/pdf/latest/ Github Documentation Link: https://candela.readthedocs.io/en/latest/index.html 5.1 Candela Candela是用于Kitware的Resonant平台的可互操作的Web可视化组件的开源套件, 致力于通过标准化API提供可扩展的丰富可视化效果，以用于现实世界的数据科学应用程序。 集成组件包括： LineUp组件：由哈佛大学视觉计算小组和Caleydo项目进行的LineUp动态排名。 UpSet组件：哈佛大学视觉计算小组和Caleydo项目的UpSet集可视化。 OnSet组件：由乔治亚理工学院信息接口小组提供的OnSet可视化设置。 华盛顿大学互动数据实验室的Vega可视化。示例组件：ScatterPlot。 通过Kitware的Resonant平台进行的GeoJS地理空间可视化。示例组件：GeoDots。 5.1.1 开始 5.1.1.1 快速开始 – JavaScript 在名为index.html的文本文件中输入以下内容： &lt;body&gt; &lt;div id=&quot;vis&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var data = [ {x: 1, y: 3}, {x: 2, y: 4}, {x: 2, y: 3}, {x: 0, y: 1} ]; var el = document.getElementById(&#39;vis&#39;); var vis = new candela.components.ScatterPlot(el, { data: data, x: &#39;x&#39;, y: &#39;y&#39; }); vis.render(); &lt;/script&gt; &lt;/body&gt; 在浏览器中打开index.html以显示结果可视化。 5.1.1.2 快速开始 – Python 请确保您已安装Python 2.7和pip（在Linux和OS X系统上，本地软件包管理器应该足够了；对于Windows，请 参见此处）。 打开一个shell程序（例如OS X上的终端; Linux上的Bash或Windows上的命令提示符），然后使用以下命令来安装Candela软件包和Requests库，以从网络上获取示例数据： pip install pycandela requests 在UNIX系统上，您可能需要在root或用sudo执行此操作 发出以下命令以在浏览器中启动Jupyter Notebook服务器： jupyter-notebook Create a notebook from the New menu and enter the following in a cell, followed by Shift-Enter to execute the cell and display the visualization: 从“新建”菜单创建一个笔记本，然后在单元格中输入以下内容，然后按Shift-Enter键执行该单元格并显示可视化效果： import requests data = requests.get( &#39;https://raw.githubusercontent.com/vega/vega-datasets/gh-pages/data/iris.json&#39; ).json() import pycandela pycandela.components.ScatterPlot( data=data, color=&#39;species&#39;, x=&#39;sepalLength&#39;, y=&#39;sepalWidth&#39;) 5.1.1.3 快速开始 – R 下载并安装RStudio。 运行以下指令以安装Candela： install.packages(&#39;devtools&#39;) devtools::install_github(&#39;Kitware/candela&#39;, subdir=&#39;R/candela&#39;) 使用以下指令以显示mtcars数据集的散点图： library(candela) candela(&#39;ScatterPlot&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) 5.2 Candela 包使用 5.2.1 安装 有两种方式可安装Candela。从标准组件仓库中下载（例如npm）或者从Python包索引（PyPI）中下载。从组件仓库中下载的方式比较简单，但仅限于能够下载公共发布版本；从源头下载稍显复杂，但能让你下载并运行最新开发版本。 5.2.1.1 从组件管理系统中安装 5.2.1.1.1 JavaScript 要安装Candela Javascript代码库至当前文件夹，执行以下代码： npm install candela 要安装Candela JavaScript代码库作为你网页应用的dependency, 并且将其加入你的package.json文件中, 执行以下代码: npm install --save candela 独立的JavaScript Candela包可以在node_modules/candela/dist/candela[.min].js中找到。 使用Webpack安装 如果您的项目使用Webpack构建过程，则可以使用Candela的捆绑式Webpack帮助程序功能轻松地将Candela包括在项目中，而不必使用完整大小的捆绑文件。概念是根据项目的需要直接包含Candela源文件，依靠Webpack帮助程序来安排要使用的正确加载程序和其他配置选项。例如，如果没有Webpack，您的源文件可能包含如下行： var candela = require(&#39;candela/dist/candela.min.js&#39;); var ScatterPlot = candela.components.ScatterPlot; 这将导致您的应用程序在运行时加载整个Candela捆绑包，如果您只想使用ScaterPlot组件，则可能不是最佳选择。相反，使用Webpack，可以按以下方式强制转换此代码： var ScatterPlot = require(&#39;candela/components/ScatterPlot&#39;); 为了确保您的构建过程为此文件使用了正确的加载程序，您应确保在项目的Webpack配置中使用Candela webpack帮助程序功能： var candelaWebpack = require(&#39;candela/webpack&#39;); module.exports = candelaWebpack({ // 这里是你原本的webpack设置 }); 这种方法使您的代码更简洁，更有意义，同时避免了不必要的大型应用程序包。 5.2.1.1.2 Python 可以在Python Package Index中找到适用于Candela的Python绑定的最新发行版。安装Candela的最简单方法是通过Python的软件包管理器Pip: 1. 安装依赖软件 安装以下软件: Python 2.7 Pip 在Linux和OS X计算机上，本地软件包管理器应足以安装它们。在Windows上，请查阅本指南以获取有关Python和Pip的建议。 2. 安装Candela Python软件包 在shell中使用这行指令来安装Candela包以及依赖项： pip install pycandela 您可能需要以管理员账户身份运行此命令，或使用使用sudo或类似方式。 5.2.1.2 从源头进行构建安装 在进行源头安装前，您需要使用以下Git指令克隆Candela的代码仓库: git clone git://github.com/Kitware/candela.git 该指令会创建一个名为candela的目录。里面包含了Candela的源代码。使用cd指令进入目录： cd candela 5.2.1.2.1 JavaScript Candela在GitHub上进行开发。如果您希望贡献代码或获取到最新开发版本，则可以按照以下步骤从GitHub下载，构建和安装： 1.下载依赖软件 要从源代码构建Candela，您将需要安装以下软件： Git Node.js npm cairo (在macOS操作系统上使用brew install cairo) 2.安装节点依赖项 使用以下指令以通过节点软件包管理器（NPM）安装必要的节点依赖项： npm install 需要的软件包将会被安装至名为node_modules的目录中。 3.开始构建过程 使用以下指令开始开始构建过程： npm run build 输出将会在build/candela/candela.js中创建一个构建完成的Candela软件包。 观察输出是否有任何错误。大多数情况下，指令运行错误会终止整个构建过程，并打印出具体错误信息。如果你需要任何解读错误信息的帮助，请在GitHub issues或者Gitter chat里给我们留言。 4.查看示例 Candela包含了许多测试需要的示例。它们也有助于学习Candela提供的多种可视化效果。要构建示例，请执行以下代码： npm run build:examples 查看示例，执行以下代码： npm run examples 5.运行测试套件 Candela配有一系列测试。要运行测试套件，你需要调用测试任务如下： npm run test:all 以上代码会执行单元以及图像测试。每个测试套件可单独用以下代码运行： npm run test:unit 以及： npm run test:image 以上每行指令都会在命令行生成摘要报告。 6. 建立文件 Candela使用ReadTheDocs主机上托管的Sphinx 文档。要在本地构建文档，请首先安装所需的Python依赖项： pip install -r requirements-dev.txt 当安装完成后，运行以下指令： npm run docs 文档将托管在 http://localhost:3000/ 主机上。 5.2.1.2.2 Python 1. 安装软件依赖项 要从Python使用Candela，您将需要Python 2.7和pip。 2.在本地安装库 pip install -e . 3.测试安装 使用以下指令以在浏览器中启动Jupyter Notebook服务器： jupyter-notebook 从“新建”菜单中创建一个笔记本，然后在单元格中输入以下内容，然后按Shift-Enter键执行该单元格并显示可视化效果： import requests data = requests.get( &#39;https://raw.githubusercontent.com/vega/vega-datasets/gh-pages/data/iris.json&#39; ).json() import pycandela pycandela.components.ScatterPlot( data=data, color=&#39;species&#39;, x=&#39;sepalLength&#39;, y=&#39;sepalWidth&#39;) 5.2.1.2.3 R-使用install_github或Git Checkout 此过程将直接从GitHub或从Candela的本地Git Checkout安装Candela。 1.安装R，并选择性安装RStudio 2.安装Candela软件包 要直接从GitHub安装： install.packages(&#39;devtools&#39;) devtools::install_github(&#39;Kitware/candela&#39;, subdir=&#39;R/candela&#39;, dependencies = TRUE) 要从Git checkout安装，请将工作目录设置为Git checkout，然后安装并检查安装。check()将运行测试并执行其他程序包检查。 install.packages(&#39;devtools&#39;) devtools::install(dependencies = TRUE) devtools::check() 3.测试安装 下面将创建mtcars数据集的散点图并将其保存到out.html： w &lt;- candela(&#39;ScatterPlot&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) htmlwidgets::saveWidget(w, &#39;out.html&#39;) 在RStudio中，当您引用可视化而不将其分配给变量时，可视化将出现在您的应用程序中： w 注意： saveWidget在RStudio外部运行时，需要安装Pandoc。请参阅安装说明进行安装。 5.2.2 版本控制 Candela 使用语义法版本命名法来命名版本号。这意味着每个发行版的版本号都可以确定该发行版中存在的功能级别和向后兼容性。 Candela的版本号有两种形式: x.y 和 x.y.z。x为主版本号, y为次版本号, z为补丁版本号。 遵循语义版本控制方法，主要版本代表了整个软件的稳定API。如果主版本号增加，则意味着可以向后兼容。也就是说，适用于1.3版的设置将适用于1.4、1.5和1.10版，但不应期望与2.0版一起使用。 次版本号代表了在前版中加入了新功能。所以1.1版将包含1.0版中未提供的某些功能，且可以确保向后兼容。 当对软件进行错误修复或其他更正时，补丁版本号将递增。 主版本号0比较特殊：本质上，在0.y系列中不保证兼容性。API和行为的稳定性从1.0版开始。 除了标准的语义版本控制做法外，Candela还在Git存储库中将当前版本号标记为“ dev”，从而为从源代码构建的Candela软件包产生了诸如“ 1.1dev”的版本号。发行协议会在将包上传到Python包索引之前，从版本号中删除该标签。 5.3 组件 5.3.1 条形图 (BarChart) 条形图。 x变量应为每个条形包含不同的值，而y变量将对应于每个条形的高度。颜色变量可用于为每个条着色。在单个x值有多个记录的情况下，可以使用合计将值组合成单个条。 该组件可以在candela/plugins/vega插件中找到。 5.3.1.1 示例 JavaScript &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: d }); } var vis = new candela.components.BarChart(el, { data: data, x: &#39;a&#39;, y: &#39;b&#39; }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: d} for d in range(10)] pycandela.components.BarChart(data=data, x=&#39;a&#39;, y=&#39;b&#39;) R library(candela) candela(&#39;BarChart&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) 5.3.1.2 可选参数 data (Table) 数据表。 x (String) x轴（条形位置）变量。 必须包含数字类数据。 请参见坐标轴刻度。 xType (String) x变量的数据类型。 默认值为’nominal’。 y (String) y轴（条形高度）变量。 必须包含数字类数据。 请参见坐标轴刻度。 yType (String) y变量的数据类型。 默认值为’quantitative’。 color (String) 用于为条形着色的变量。 colorType (String) 颜色变量的数据类型。 默认值为’nominal’。 aggregate (String) 当多个记录中的x值相同时，y值的合计模式。 默认值为’sum’。 width (Number) 图表的宽度（以像素为单位）。 请参阅调整大小。 height (Number) 图表的高度（以像素为单位）。 请参阅调整大小。 renderer (String) 是否以’svg’或’canvas’模式渲染（默认为’画布’）。 5.3.2 箱线图 (BoxPlot) 箱线图。可视化采用一组测量数据（变量），并为每个测量生成箱线图。可选的group变量会将数据划分为具有匹配数值的小组，并为每个组创建一个或一组箱形图。 该组件可以在candela/plugins/vega插件中找到。 5.3.2.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: d/2 + 7 }); } var vis = new candela.components.BoxPlot(el, { data: data, fields: [&#39;a&#39;, &#39;b&#39;] }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python data = [{&#39;a&#39;: d, &#39;b&#39;: d/2 + 7} for d in range(10)] pycandela.components.BoxPlot(data=data, fields=[&#39;a&#39;, &#39;b&#39;]) R library(candela) candela(&#39;BoxPlot&#39;, data=mtcars, fields=c(&#39;mpg&#39;, &#39;wt&#39;, &#39;disp&#39;)) 5.3.2.2 可选参数 data (Table) 数据表。 fields (Array of String) 用作于测量的变量。 可视化将为每个变量生成一个箱线图。必须包含数字或时间数据。请参见坐标轴刻度。 坐标轴类型将由数组中第一个变量的推断值选择。 x (String) group by 所使用的可选参数。 默认情况下，所有记录都放在一个组中。 请参见轴刻度。 x轴（条形位置）变量。 必须包含数字类数据。 请参见坐标轴刻度。 xType (String) x变量的数据类型。 默认值为’nominal’。 color (String) 用于为箱形图着色的变量。 colorType (String) 颜色变量的数据类型。 默认值为’nominal’。 width (Number) 图表的宽度（以像素为单位）。 请参阅调整大小。 height (Number) 图表的高度（以像素为单位）。 请参阅调整大小。 renderer (String) 是否以’svg’或’canvas’模式渲染（默认为’画布’）。 5.3.3 甘特图 (GanttChart) 甘特图。 数据表必须包含两个数字变量，start和end，用于指定水平条的开始和结束。 label变量可以指定每个项目的名称。 该组件可以在candela/plugins/vega插件中找到。 5.3.3.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = [ {name: &#39;Do this&#39;, level: 1, start: 0, end: 5}, {name: &#39;This part 1&#39;, level: 2, start: 0, end: 3}, {name: &#39;This part 2&#39;, level: 2, start: 3, end: 5}, {name: &#39;Then that&#39;, level: 1, start: 5, end: 15}, {name: &#39;That part 1&#39;, level: 2, start: 5, end: 10}, {name: &#39;That part 2&#39;, level: 2, start: 10, end: 15} ]; var vis = new candela.components.GanttChart(el, { data: data, label: &#39;name&#39;, start: &#39;start&#39;, end: &#39;end&#39;, level: &#39;level&#39;, width: 700, height: 200 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ dict(name=&#39;Do this&#39;, level=1, start=0, end=5), dict(name=&#39;This part 1&#39;, level=2, start=0, end=3), dict(name=&#39;This part 2&#39;, level=2, start=3, end=5), dict(name=&#39;Then that&#39;, level=1, start=5, end=15), dict(name=&#39;That part 1&#39;, level=2, start=5, end=10), dict(name=&#39;That part 2&#39;, level=2, start=10, end=15) ]; pycandela.components.GanttChart( data=data, label=&#39;name&#39;, start=&#39;start&#39;, end=&#39;end&#39;, level=&#39;level&#39;, width=700, height=200 ) R library(candela) data &lt;- list( list(name=&#39;Do this&#39;, level=1, start=0, end=5), list(name=&#39;This part 1&#39;, level=2, start=0, end=3), list(name=&#39;This part 2&#39;, level=2, start=3, end=5), list(name=&#39;Then that&#39;, level=1, start=5, end=15), list(name=&#39;That part 1&#39;, level=2, start=5, end=10), list(name=&#39;That part 2&#39;, level=2, start=10, end=15)) candela(&#39;GanttChart&#39;, data=data, label=&#39;name&#39;, start=&#39;start&#39;, end=&#39;end&#39;, level=&#39;level&#39;, width=700, height=200) 5.3.3.2 可选参数 data (Table) 数据表。 label (String) 用于标记每个任务的字段。 start (String) 代表每个任务结束开始的变量。 必须为数字。 end (String) 代表每个任务结束刻度的变量。 必须为数字。 level (String) 用作分层项目级别的字符串。 当前支持两个不同的值，遇到的第一个值将是级别1，该级别将展现的更为突出，而第二个值将是级别2。 type (String) 开始和结束变量的数据类型。 默认值为’quantitative’。 tickCount (String) 建议沿x轴放置的刻度线数量。 axisTitle (String) x轴的标题。 width (Number) 图表的宽度（以像素为单位）。 请参阅调整大小。 height (Number) 图表的高度（以像素为单位）。 请参阅调整大小。 renderer (String) 是否以’svg’或’canvas’模式渲染（默认为’画布’）。 5.3.4 地理空间图 (Geo) 使用GeoJS的地理空间图。 该组件可以在candela/plugins/geojs插件中找到。 5.3.4.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.style.width = &#39;500px&#39;; el.style.height = &#39;500px&#39;; document.body.appendChild(el); var data = [ {lat: 41.702, lng: -87.644}, {lat: 41.617, lng: -87.693}, {lat: 41.715, lng: -87.712} ]; var vis = new candela.components.Geo(el, { map: { zoom: 10, center: { x: -87.6194, y: 41.867516 } }, layers: [ { type: &#39;osm&#39; }, { type: &#39;feature&#39;, features: [ { type: &#39;point&#39;, data: data, x: &#39;lng&#39;, y: &#39;lat&#39; } ] } ] }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ dict(lat=41.702, lng=-87.644), dict(lat=41.617, lng=-87.693), dict(lat=41.715, lng=-87.712) ] pycandela.components.Geo( map=dict( zoom=10, center=dict(x=-87.6194, y=41.867516) ), layers=[ dict(type=&#39;osm&#39;), dict( type=&#39;feature&#39;, features=[ dict(type=&#39;point&#39;, data=data, x=&#39;lng&#39;, y=&#39;lat&#39;) ] ) ] ) R library(candela) data = list( list(lat=41.702, lng=-87.644), list(lat=41.617, lng=-87.693), list(lat=41.715, lng=-87.712)) candela(&#39;Geo&#39;, map=list( zoom=10, center=list(x=-87.6194, y=41.867516) ), layers=list( list(type=&#39;osm&#39;), list( type=&#39;feature&#39;, features=list( list(type=&#39;point&#39;, data=data, x=&#39;lng&#39;, y=&#39;lat&#39;) ) ) ) ) 5.3.4.2 可选参数 map (Object) 描述GeoJS地图选项的key-value对。 layers (Array of Layer) 地图的图层。 5.3.4.3 Layers详述 图层包含描述GeoJS图层选项的key-value对。 这些选项会传递给GeoJS，但type设置为’feature’的图层的’feature’选项除外。 在这种情况下，’feature’选项是一组Feature的详述。 5.3.4.4 Feature详述 每个feature都是具有以下属性的对象： name (String) feature的名字。 type (String) feature的类 （现支持：‘point’）。 data (Table) 数据表。 x (String) 用于feature的x轴参数。 y (String) 用于feature的y轴参数。 5.3.5 地理点图(GeoDots) 使用GeoJS的地理空间视图，其位置用点标记。 纬度（latitude）和经度 （longitude）变量包含数据中每个位置的经/纬度值。 该组件可以在candela/plugins/geojs插件中找到。 5.3.5.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.style.width = &#39;500px&#39;; el.style.height = &#39;500px&#39;; document.body.appendChild(el); var data = [ {lat: 41.702, lng: -87.644, a: 5}, {lat: 41.617, lng: -87.693, a: 15}, {lat: 41.715, lng: -87.712, a: 25} ]; var vis = new candela.components.GeoDots(el, { zoom: 10, center: { longitude: -87.6194, latitude: 41.867516 }, data: data, latitude: &#39;lat&#39;, longitude: &#39;lng&#39;, size: &#39;a&#39;, color: &#39;a&#39; }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ dict(lat=41.702, lng=-87.644, a=5), dict(lat=41.617, lng=-87.693, a=15), dict(lat=41.715, lng=-87.712, a=25) ] pycandela.components.GeoDots( zoom=10, center=dict(longitude=-87.6194, latitude=41.867516), data=data, latitude=&#39;lat&#39;, longitude=&#39;lng&#39;, size=&#39;a&#39;, color=&#39;a&#39; ) R library(candela) data = list( list(lat=41.702, lng=-87.644, a=5), list(lat=41.617, lng=-87.693, a=15), list(lat=41.715, lng=-87.712, a=25)) candela(&#39;GeoDots&#39;, zoom=10, center=list(longitude=-87.6194, latitude=41.867516), data=data, latitude=&#39;lat&#39;, longitude=&#39;lng&#39;, size=&#39;a&#39;, color=&#39;a&#39;) 5.3.5.2 可选参数 data (Table) 数据表。 longitude (String) 经度变量。 latitude (String) 纬度变量。 color (String) 用来为点着色的变量。 size (String) 用来确定点的大小的变量。 该字段必须包含数字值。 zoom (Integer) 初始缩放程度。 center (Object) 具有经度和纬度属性的对象，用于指定地图的初始中心。 tileUrl (String) 切片URL模板（请参见GeoJS OSM图层选项）。 设置为null可完全禁用OSM层。 5.3.6 图级操作 (GLO - Graph-Level Operations) 可视化框架。将数据看作图形的节点，使用定位和视觉命令将它们排列为不同的格式，以实现不同的可视化。 节点表包含一个对象列表，每个对象都有一个包含唯一标识符的id变量以及所需的其他数据属性。边缘表（edges table）包含源头和目标变量（各自指向引用节点表中的id值）、无向或有向的可选类变量、标识每个边缘的id参数、以及权重值（可选）。 width和height控制用于呈现可视化效果的画布的大小。 该组件可以在candela/plugins/glo插件中找到。 5.3.6.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.setAttribute(&#39;width&#39;, 700); el.setAttribute(&#39;width&#39;, 700); document.body.appendChild(el); var alphabet = &#39;abcdefghijklmnopqrstuvwxyz&#39;; var vowels = &#39;aeiou&#39;.split(&#39;&#39;); var nodes = []; for (var i = 0; i &lt; 26; i++) { var letter = { id: i, label: alphabet[i], vowel: vowels.indexOf(alphabet[i]) &gt; 0 ? &#39;vowel&#39; : &#39;consonant&#39; }; for (var j = 0; j &lt; 26; j++) { letter[alphabet[j]] = Math.abs(j - i); } nodes.push(letter); } var edges = []; var counter = 0; for (var i = 0; i &lt; 26; i++) { for (var j = i + 1; j &lt; 26; j++) { if (nodes[i][alphabet[j]] &gt; 20) { edges.push({ source: i, target: j, type: &#39;Undirected&#39;, id: counter++, weight: 1 }); } } } var vis = new candela.components.Glo(el, { nodes: nodes, edges: edges, width: 700, height: 200 }); vis.render(); vis.distributeNodes(&#39;x&#39;); vis.colorNodesDiscrete(&#39;vowel&#39;); vis.curvedEdges(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ {&#39;id&#39;: 0, &#39;label&#39;: &#39;A&#39;, &#39;class&#39;: 0}, {&#39;id&#39;: 1, &#39;label&#39;: &#39;B&#39;, &#39;class&#39;: 1}, {&#39;id&#39;: 2, &#39;label&#39;: &#39;C&#39;, &#39;class&#39;: 1} ] edges = [ {&#39;id&#39;: 0, &#39;source&#39;: 0, &#39;target&#39;: 1}, {&#39;id&#39;: 1, &#39;source&#39;: 0, &#39;target&#39;: 2}, {&#39;id&#39;: 2, &#39;source&#39;: 2, &#39;target&#39;: 1} ] glo = pycandela.components.Glo(nodes=nodes, edges=edges) glo.render() glo.distributeNodes(&#39;x&#39;); glo.colorNodesDiscrete(&#39;class&#39;); glo.curvedEdges(); R library(candela) id = c(0, 1, 2) label = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) class = c(0, 1, 1) nodes = data.frame(id, label, class) source = c(0, 0, 2) target = c(1, 2, 1) edges = data.frame(id, source, target) glo = candela(&#39;SimilarityGraph&#39;, nodes=nodes, edges=edges) glo.render() glo.distributeNodes(&#39;x&#39;) glo.colorNodesDiscrete(&#39;class&#39;) glo.curvedEdges() 5.3.6.2 可选参数 nodes (Table) 节点表。 edges (Table) 边缘表。 width (number) 绘图区域宽度。 height (number) 绘图区域高度。 5.3.6.3 函数方程 colorNodesDiscrete(field) 参数： - field (string) – 要着色的变量 使用分类颜色图（color map）通过变量中的值为节点着色。 colorNodesContinuous(field) 参数： - field (string) – 要着色的变量 使用连续的颜色图（color map）通过变量中的值为节点着色。 colorNodesDefault() 将节点颜色恢复为默认状态（无颜色图）。 sizeNodes(field) 参数： - field (string) – 用于调整大小的变量 根据变量中的值调整节点的大小。 sizeNodesDefault() 将节点大小恢复为默认状态（固定大小）。 distributeNodes(axis[, attr]) 参数： - string (attr) – 分布节点的轴 -string -– 用于对节点进行分组的参数 沿轴均匀放置节点，该轴必须是“ x”，“ y”，“ rho”（径向轴）或“ theta”（角度轴）之一。如果指定了attr，则将根据此attr对节点进行分区和分组。 positionNodes(axis, value) 参数: - axis (string) – 分布节点的轴 - value (string|number) – 用于绘制位置数据的变量或常量 根据值中的数据沿轴定位节点（请参见distributionNodes()）。如果value是字符串，则表示节点表中的列；如果是数字，则所有节点都将被放置于该位置。 forceDirected() 将力导引算法（force-directed positioning）应用于节点。 showEdges() 展示所有节点之间的边。 hideEdges() 隐藏所有节点之间的边。 fadeEdges() 使用透明的灰色渲染边缘。 solidEdges() 使用黑色渲染边缘。 incidentEdges() 仅在鼠标指针悬停在节点上时，渲染入射在该节点上的边缘。 curvedEdges() 使用曲线渲染边缘。 straightEdges() 使用直线渲染边缘。 5.3.7 直方图 (Histogram) 直方图。参数bin指定要汇总的字段。默认情况下，数据表data中的每条记录占bin的总数的1。 通过指定一个汇总字段aggregate，将在每个bin里加总该字段。 该组件可以在candela/plugins/vega插件中找到。 5.3.7.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 1000; d += 1) { data.push({ a: Math.sqrt(-2*Math.log(Math.random()))*Math.cos(2*Math.PI*Math.random()) }); } var vis = new candela.components.Histogram(el, { data: data, x: &#39;a&#39;, width: 700, height: 400 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela from random import normalvariate as nv data = [{&#39;a&#39;: nv(0, 1)} for d in range(1000)] pycandela.components.Histogram(data=data, x=&#39;a&#39;, width=700, height=400) R library(candela) candela(&#39;Histogram&#39;, data=mtcars, x=&#39;mpg&#39;) 5.3.7.2 可选参数 data (Table) 数据表。 x (String) x轴字段，组合为直方图。 xType (String) x字段的数据类型。默认值是“名义变量”。 aggregate (String) 每个直方图bin中y值的聚合模式。默认值为“计数”，它不使用y值，但将统计bin中出现的记录数。 y (String) y轴字段，当没设置聚合为“计数”时，用于确定直方图条的高度。 yType (String) y字段的数据类型。默认值为“定量”。 color (String) 用于为条形着色的字段。 colorType (String) 颜色字段的数据类型。默认值为“名义变量”。 width (Number) 图表的宽度（以像素为单位）。请参阅API文件的尺寸调整。 height (Number) 图表的高度（以像素为单位）。请参阅API文件的尺寸调整。 renderer (String) 以“矢量图形(svg)”或“画布(canvas)”绘制图像。（默认为“画布”）。 5.3.8 折线图 (LineChart) 折线图。该图表针对单个x字段绘制了y字段的线，可以选择使用系列字段series将其分成多条线。 该组件可以在candela/plugins/vega插件中找到。 5.3.8.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: d }); } var vis = new candela.components.LineChart(el, { data: data, x: &#39;a&#39;, y: &#39;b&#39;, width: 700, height: 400 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: d} for d in range(10)] pycandela.components.LineChart( data=data, x=&#39;a&#39;, y=&#39;b&#39;, width=700, height=400) R library(candela) candela(&#39;LineChart&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) 5.3.8.2 可选参数 data (Table) 数据表。 x (String) x轴字段，组合为直方图。 xType (String) x字段的数据类型。默认值是“名义变量”。 y (String) y轴字段，当没设置聚合为“计数”时，用于确定直方图条的高度。 yType (String) y字段的数据类型。默认值为“定量”。 series (String) 用于将数据分隔成多行的可选字段。 seriesType (String) 序列字段的数据类型。默认值为“名义变量”。 colorSeries (Boolean) 是否为不同序列上色并显示图例。默认为“是”。 showPoints (Boolean) 是否在直线上添加点。默认值为“否”。 width (Number) 图表的宽度（以像素为单位）。请参阅API文件的尺寸调整。 height (Number) 图表的高度（以像素为单位）。请参阅API文件的尺寸调整。 renderer (String) 以“矢量图形(svg)”或“画布(canvas)”绘制图像。（默认为“画布”）。 5.3.9 排序图(Lineup) LineUp用于排名可视化。 可以在candela/plugins/lineup插件中找到该组件。 5.3.9.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: 10 - d, name: d }); } var vis = new candela.components.LineUp(el, { data: data, fields: [&#39;a&#39;, &#39;b&#39;] }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: 10 - d, &#39;name&#39;: d} for d in range(10)] pycandela.components.LineUp(data=data, fields=[&#39;a&#39;, &#39;b&#39;]) R library(candela) candela(&#39;LineUp&#39;, data=mtcars, fields=c(&#39;_row&#39;, &#39;mpg&#39;, &#39;wt&#39;, &#39;disp&#39;)) 5.3.9.2 可选参数 data (Table) 数据表。 fields (Array of String) 将在LineUp视图上显示的字段列表。该列表确定字段的顺序。如果未提供，则显示数据中的所有字段。 stacked (Boolean) 是否将分组的度量显示为堆叠的条形（默认为“否”）。 histograms (Boolean) 是否在每个度量的标题中显示直方图（默认为“是”）。 animation (Boolean) 是否在评分标准更改时设置过渡动画（默认为“是”）。 5.3.10 OnSet组件 (OnSet) 5.3.10.1 示例 OnSet集合可视化. OnSet将二进制列（即每行中文本为“ 0”或“ 1”，“true”或“false”，“yes”或“no”的列）解释为集合。 sets选项中的任何字段都将以这种方式解释。 由于大多数数据不是按二进制列排列的，因此可视化还通过field选项支持任意类别的字段。 此列表中指定的每个字段首先将被预处理为一个集合集，每个集合值对应的名称为&lt;fieldName&gt;&lt;value&gt; 例如，假设数据表为： [ {&quot;id&quot;: &quot;n1&quot;, &quot;f1&quot;: 1, &quot;f2&quot;: &quot;x&quot;}, {&quot;id&quot;: &quot;n2&quot;, &quot;f1&quot;: 0, &quot;f2&quot;: &quot;x&quot;}, {&quot;id&quot;: &quot;n3&quot;, &quot;f1&quot;: 0, &quot;f2&quot;: &quot;y&quot;} ] 可以使用以下选项创建OnSet可视化： new OnSet({ data: data, id: &#39;id&#39;, sets: [&#39;f1&#39;], fields: [&#39;f2&#39;] }); 如下所示，这会将f2字段预处理为f2 x和f2 y，并使它们可用于OnSet： f1: n1 f2 x: n1, n2 f2 y: n3 如果rowSets选项设置为true，则集合将转变为： n1: f1, f2 x n2: f2 x n3: f2 y 该组件可以在candela/plugins/onset插件中找到。 5.3.10.2 可选参数 data (Table) 数据表。 id (String) 包含每个记录的唯一ID的字段。 fields (Array of String) 分类字段的列表，这些字段将每个字段中每个不同值的转换为0/1组集合，并填充在OnSet视图中。 rowSets (Boolean) 如果为false，则将列视为集合；如果为true，则将行视为集合。默认为“否”。 5.3.11 散点图 (ScatterPlot) 散点图。 该可视化将在指定的x和y位置绘制值。其他字段可以确定绘制点的颜色color，大小size和形状shape。 该组件可以在candela/plugins/vega插件中找到。 #### 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: d }); } var vis = new candela.components.ScatterPlot(el, { data: data, x: &#39;a&#39;, y: &#39;b&#39;, width: 700, height: 400 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: d} for d in range(10)] pycandela.components.ScatterPlot( data=data, x=&#39;a&#39;, y=&#39;b&#39;, width=700, height=400) R library(candela) candela(&#39;ScatterPlot&#39;, data=mtcars, x=&#39;mpg&#39;, y=&#39;wt&#39;, color=&#39;disp&#39;) 5.3.11.1 可选参数 data (Table) 数据表。 x (String) x轴字段。 xType (String) x字段的数据类型。默认值是“名义变量”。 y (String) y轴字段。 yType (String) y字段的数据类型。默认值为“定量”。 color (String) 该字段用于给点上色。 colorType (String) color颜色字段的数据类型。默认为“名义变量”。 size (String) 该字段用于改变点的大小。 sizeType (String) size大小字段的数据类型。默认值为“定量”。 shape (String) 该字段用于改变点的形状。 shapeType (String) shape形状字段的数据类型。默认值为“名义变量”。 filled (String) 是填充点还是仅绘制轮廓。默认值为“是”。 width (Number) 图表的宽度（以像素为单位）。请参阅API文件的尺寸调整。 height (Number) 图表的高度（以像素为单位）。请参阅API文件的尺寸调整。 renderer (String) 以“矢量图形(svg)”或“画布(canvas)”绘制图像。（默认为“画布”）。 5.3.12 散点图矩阵 (ScatterPlotMatrix) 散点图矩阵。该可视化将为每对指定字段fields绘制散点图。其他字段可以确定点的大小size，颜色color和形状shape。 该组件可以在candela/plugins/vega插件中找到。 5.3.12.1 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) document.body.appendChild(el); var data = []; for (var d = 0; d &lt; 10; d += 1) { data.push({ a: d, b: 10 - d, name: d }); } var vis = new candela.components.ScatterPlotMatrix(el, { data: data, fields: [&#39;a&#39;, &#39;b&#39;] }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [{&#39;a&#39;: d, &#39;b&#39;: 10 - d, &#39;name&#39;: d} for d in range(10)] pycandela.components.ScatterPlotMatrix(data=data, fields=[&#39;a&#39;, &#39;b&#39;]) R library(candela) candela(&#39;ScatterPlotMatrix&#39;, data=mtcars, fields=c(&#39;mpg&#39;, &#39;wt&#39;, &#39;disp&#39;)) 5.3.12.2 可选参数 data (Table) 数据表。 fields (Array of String) 该字段在散点图矩阵中用作轴。指定N个字段将生成N x N的散点图矩阵。 color (String) 该字段用于给点上色。 colorType (String) 颜色字段的数据类型。默认为“名义变量”。 size (String) 该字段用于改变点的大小。 sizeType (String) size大小字段的数据类型。默认值为“定量”。 shape (String) 该字段用于改变点的形状。 shapeType (String) shape形状字段的数据类型。默认值为“名义变量”。 filled (String) 是填充点还是仅绘制轮廓。默认值为“是”。 width (Number) 图表的宽度（以像素为单位）。请参阅API文件的尺寸调整。 height (Number) 图表的高度（以像素为单位）。请参阅API文件的尺寸调整。 renderer (String) 以“矢量图形(svg)”或“画布(canvas)”绘制图像。（默认为“画布”）。 5.3.13 词树 (SentenTree) 词树：句子可视化。 给定一个有关某个主题的文本样本表，SentenTree尝试抽象出它们之间的共同表达，将它们可视化为“句子树”。 数据表data包含一系列对象，每个对象都有一个id字段，该字段包含每行的唯一标识符，一个文本text字段，包含文本样本，一个计数count字段，表示该样本的强度或在语料库中发生的次数等。 可以在candela/plugins/sententree插件中找到此组件。 #### 示例 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.setAttribute(&#39;width&#39;, 1200); el.setAttribute(&#39;width&#39;, 700); document.body.appendChild(el); var data = [ {id: 0, count: 3787, text: &#39;brazil\\&#39;s marcelo scores the first goal of the world cup ... against brazil.&#39;}, {id: 1, count: 2878, text: &#39;at least brazil have scored the first goal of the world cup&#39;}, {id: 2, count: 1702, text: &#39;first game of the world cup tonight! can\\&#39;t wait!&#39;}, {id: 3, count: 1689, text: &#39;the first goal of the world cup is an own goal! marcelo accidentally knocks it into his own net past julio cesar! croatia leads 1-0.&#39;}, {id: 4, count: 1582, text: &#39;goal: brazil 0-1 croatia marcelo scores an own goal in the 11th minute&#39;}, {id: 5, count: 1525, text: &#39;just like we predicted, a brazilian scored the first goal in the world cup&#39;}, {id: 6, count: 1405, text: &#39;whoever bet that the first goal of the world cup was going to be an own goal just made a lot of money.&#39;}, {id: 7, count: 1016, text: &#39;736 players 64 matches 32 teams 12 stadiums 4 years of waiting 1 winning country the 2014 world cup has started .&#39;}, {id: 9, count: 996, text: &#39;watching the world cup tonight! with the tour fam&#39;}, {id: 10, count: 960, text: &#39;the first goal of the world cup was almost as bad as the opening ceremony.&#39;}, {id: 11, count: 935, text: &#39;live from the 2014 fifa world cup in brazil, the unveiling of the happiness flag.&#39;}, {id: 13, count: 915, text: &#39;world cup starts today!!!!!! amazing!!!&#39;}, {id: 14, count: 818, text: &#39;the first goal scored of the world cup 2014... was an own goal!&#39;}, {id: 15, count: 805, text: &#39;after 4 years, the wait is finally over.&#39;}, {id: 16, count: 803, text: &#39;that\\&#39;s not in the script! own goal from marcelo puts croatia up 0-1.&#39;}, {id: 17, count: 746, text: &#39;that moment when you score an own goal in the opening game of the world cup.&#39;}, {id: 18, count: 745, text: &#39;scoring on themselves in the world cup&#39;}, {id: 19, count: 719, text: &#39;world cup 2014 first goal is own-goal by marcelo&#39;} ]; var vis = new candela.components.SentenTree(el, { data: data, graphs: 3 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ {&#39;id&#39;: 0, &#39;count&#39;: 3787, &#39;text&#39;: &#39;brazil\\&#39;s marcelo scores the first goal of the world cup ... against brazil.&#39;}, {&#39;id&#39;: 1, &#39;count&#39;: 2878, &#39;text&#39;: &#39;at least brazil have scored the first goal of the world cup&#39;}, {&#39;id&#39;: 2, &#39;count&#39;: 1702, &#39;text&#39;: &#39;first game of the world cup tonight! can\\&#39;t wait!&#39;}, {&#39;id&#39;: 3, &#39;count&#39;: 1689, &#39;text&#39;: &#39;the first goal of the world cup is an own goal! marcelo accidentally knocks it into his own net past julio cesar! croatia leads 1-0.&#39;}, {&#39;id&#39;: 4, &#39;count&#39;: 1582, &#39;text&#39;: &#39;goal: brazil 0-1 croatia marcelo scores an own goal in the 11th minute&#39;}, {&#39;id&#39;: 5, &#39;count&#39;: 1525, &#39;text&#39;: &#39;just like we predicted, a brazilian scored the first goal in the world cup&#39;}, {&#39;id&#39;: 6, &#39;count&#39;: 1405, &#39;text&#39;: &#39;whoever bet that the first goal of the world cup was going to be an own goal just made a lot of money.&#39;}, {&#39;id&#39;: 7, &#39;count&#39;: 1016, &#39;text&#39;: &#39;736 players 64 matches 32 teams 12 stadiums 4 years of waiting 1 winning country the 2014 world cup has started .&#39;}, {&#39;id&#39;: 9, &#39;count&#39;: 996, &#39;text&#39;: &#39;watching the world cup tonight! with the tour fam&#39;}, {&#39;id&#39;: 10, &#39;count&#39;: 960, &#39;text&#39;: &#39;the first goal of the world cup was almost as bad as the opening ceremony.&#39;}, {&#39;id&#39;: 11, &#39;count&#39;: 935, &#39;text&#39;: &#39;live from the 2014 fifa world cup in brazil, the unveiling of the happiness flag.&#39;}, {&#39;id&#39;: 13, &#39;count&#39;: 915, &#39;text&#39;: &#39;world cup starts today!!!!!! amazing!!!&#39;}, {&#39;id&#39;: 14, &#39;count&#39;: 818, &#39;text&#39;: &#39;the first goal scored of the world cup 2014... was an own goal!&#39;}, {&#39;id&#39;: 15, &#39;count&#39;: 805, &#39;text&#39;: &#39;after 4 years, the wait is finally over.&#39;}, {&#39;id&#39;: 16, &#39;count&#39;: 803, &#39;text&#39;: &#39;that\\&#39;s not in the script! own goal from marcelo puts croatia up 0-1.&#39;}, {&#39;id&#39;: 17, &#39;count&#39;: 746, &#39;text&#39;: &#39;that moment when you score an own goal in the opening game of the world cup.&#39;}, {&#39;id&#39;: 18, &#39;count&#39;: 745, &#39;text&#39;: &#39;scoring on themselves in the world cup&#39;}, {&#39;id&#39;: 19, &#39;count&#39;: 719, &#39;text&#39;: &#39;world cup 2014 first goal is own-goal by marcelo&#39;} ] pycandela.components.SentenTree(data=data, id=&#39;id&#39;, count=&#39;count&#39;, text=&#39;text&#39;) R library(candela) id = c(0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19) count = c(3787, 2878, 1702, 1689, 1582, 1525, 1405, 1016, 996, 960, 935, 915, 818, 805, 803, 746, 745, 719) text = c(&#39;brazil\\&#39;s marcelo scores the first goal of the world cup ... against brazil.&#39;, &#39;at least brazil have scored the first goal of the world cup&#39;, &#39;first game of the world cup tonight! can\\&#39;t wait!&#39;, &#39;the first goal of the world cup is an own goal! marcelo accidentally knocks it into his own net past julio cesar! croatia leads 1-0.&#39;, &#39;goal: brazil 0-1 croatia marcelo scores an own goal in the 11th minute&#39;, &#39;just like we predicted, a brazilian scored the first goal in the world cup&#39;, &#39;whoever bet that the first goal of the world cup was going to be an own goal just made a lot of money.&#39;, &#39;736 players 64 matches 32 teams 12 stadiums 4 years of waiting 1 winning country the 2014 world cup has started .&#39;, &#39;watching the world cup tonight! with the tour fam&#39;, &#39;the first goal of the world cup was almost as bad as the opening ceremony.&#39;, &#39;live from the 2014 fifa world cup in brazil, the unveiling of the happiness flag.&#39;, &#39;world cup starts today!!!!!! amazing!!!&#39;, &#39;the first goal scored of the world cup 2014... was an own goal!&#39;, &#39;after 4 years, the wait is finally over.&#39;, &#39;that\\&#39;s not in the script! own goal from marcelo puts croatia up 0-1.&#39;, &#39;that moment when you score an own goal in the opening game of the world cup.&#39;, &#39;scoring on themselves in the world cup&#39;, &#39;world cup 2014 first goal is own-goal by marcelo&#39;) data = data.frame(id, count, text) candela(&#39;SentenTree&#39;, data=data, id=&#39;id&#39;, color=&#39;class&#39;, threshold=0.4) 5.3.13.1 可选参数 data (Table) 数据表。 id（String） ID字段。可以包含任何数据类型，但是该值对于每个数据记录而言都是唯一的。 text（String） 文本样本字段。 count (Integer) 表示每个文本样本的数量或强度的字段。 5.3.14 相似图 (SimilarityGraph) 交互式相似图。给定一个对其他实体的连接强度进行编码的实体列表，此组件将创建一个以实体为节点的图形，并在连接强度超过某个阈值的节点之间出现链接。 数据表data包含一个对象列表，每个对象都有一个id字段，其中包含每个实体的唯一标识符。每个对象还应该有一个由其他实体的id命名的数字字段，其中包含到每个实体的链接强度。如果缺少任何实体的链接强度，则假定其为0。每个对象可以选择包含一个颜色字段color和一个大小size字段，该颜色字段包含标识其颜色的值，大小字段可以是每个半径的数字（以像素为单位）节点，也可以是标识数据中字段的字符串，该字段包含一个将映射到每个节点半径的数字。threshold是一个数值，指定要在图中显示的链接强度的最小值。linkDistance设置所需的链接长度（以像素为单位）。 这个组件可以在candela/plugins/similaritygraph插件中找到。 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var el = document.createElement(&#39;div&#39;) el.setAttribute(&#39;width&#39;, 700); el.setAttribute(&#39;width&#39;, 700); document.body.appendChild(el); var alphabet = &#39;abcdefghijklmnopqrstuvwxyz&#39;; var vowels = &#39;aeiou&#39;.split(&#39;&#39;); var data = []; for (var i = 0; i &lt; 26; i++) { var letter = { id: alphabet[i], size: 10 + i, color: vowels.indexOf(alphabet[i]) &gt; 0 ? &#39;vowel&#39; : &#39;consonant&#39; }; for (var j = 0; j &lt; 26; j++) { letter[alphabet[j]] = Math.abs(j - i); } data.push(letter); } var vis = new candela.components.SimilarityGraph(el, { data: data, size: &#39;size&#39;, threshold: 20 }); vis.render(); &lt;/script&gt; &lt;/body&gt; Python import pycandela data = [ {&#39;id&#39;: &#39;A&#39;, &#39;class&#39;: 0, &#39;A&#39;: 1.0, &#39;B&#39;: 0.5, &#39;C&#39;: 0.3}, {&#39;id&#39;: &#39;B&#39;, &#39;class&#39;: 1, &#39;A&#39;: 0.5, &#39;B&#39;: 1.0, &#39;C&#39;: 0.2}, {&#39;id&#39;: &#39;C&#39;, &#39;class&#39;: 1, &#39;A&#39;: 0.3, &#39;B&#39;: 0.2, &#39;C&#39;: 1.0} ] pycandela.components.SimilarityGraph(data=data, id=&#39;id&#39;, color=&#39;class&#39;, threshold=0.4) R library(candela) id = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) class = c(0, 1, 1) A = c(1.0, 0.5, 0.3) B = c(0.5, 1.0, 0.2) C = c(0.3, 0.2, 1.0) data = data.frame(id, class, A, B, C) candela(&#39;SimilarityGraph&#39;, data=data, id=&#39;id&#39;, color=&#39;class&#39;, threshold=0.4) 5.3.14.1 可选参数 data (Table) 数据表。 id（String） ID字段。可以包含任何数据类型，但是该值对于每个数据记录而言都是唯一的。 color (String) 用于为节点着色的字段。请参阅API文件的色阶。 size (String or Number) 如果是字符串，则该字段用于提供每个节点的半径；如果为数字，则为所有节点使用的半径。 threshold (Number) 高于该强度临界值的链接将出现在图形中。 linkDistance (Number) 每个链接的期望长度（以像素为单位）。 5.3.15 树状图(Tree Heatmap) 带有附加到行和列的可选层次结构的热图。 该组件可以在candela / plugins / treeheatmap插件中找到。 #### 示例 以下示例假定您已下载 示例数据。 JavaScript &lt;body&gt; &lt;script src=&quot;//unpkg.com/candela/dist/candela.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;vis&quot; style=&quot;width:600px;height:600px&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; &gt; var el = document.getElementById(&#39;vis&#39;); d3.json(&#39;heatmap.json&#39;, function (error, data) { var vis = new candela.components.TreeHeatmap(el, { data: data, scale: &#39;column&#39; }); vis.render(); }); &lt;/script&gt; &lt;/body&gt; Python import pycandela import json data = json.load(open(&#39;heatmap.json&#39;)) pycandela.components.TreeHeatmap(data=data, scale=&#39;column&#39;) R library(candela) library(jsonlite) data &lt;- fromJSON( &#39;https://candela.readthedocs.io/en/latest/_static/heatmap.json&#39;) candela(&#39;TreeHeatmap&#39;, data=data, scale=&#39;column&#39;) 5.3.15.1 可选参数 data (Table) 数据表。 idColumn (String) 具有唯一标识符的列。如果未设置，则可视化将使用名称为空的列，或者(如果存在)使用名为“ _”或“ _id”的列。 scale (String) 指定是使用全局比例尺（“ global”）为数据值着色，单独缩放每一行或每一列（“ row”或“ column”）还是使用适合于相关矩阵（“correlation”）的-1到1色标。如果未指定此参数，则视图使用全局比例。 clusterRows (Boolean) 如果设置为true，则按层次集群链接对行进行排序。此选项需要专门定义的列，名称为“cluster”，“ child1”，“ _ child2”，“ _distance”和“_size”来定义行的聚类。有关如何创建适当的层次结构列的示例，请参见 pysciencedock中的 热图分析。 clusterColumns (Boolean) 如果设置为true，则按层次集群链接对列进行排序。此选项需要专门定义的名为“_cluster”，“child1”，“ child2”，“_distance”和“ _size”的行来定义列的聚类。有关如何创建适当的层次结构行的示例，请参见 pysciencedock中的 热图分析。 threshold (Number) 根据阈值模式设定阈值。 thresholdMode (String) 如果设置，则使用阈值仅显示表格中的某些单元格。有效值为“none”（无阈值），“greater than”（显示大于阈值的值），“less than”（显示小于阈值的值）或“absolute value greater than”（仅显示绝对值大于阈值的值）。如果设置为“ none”以外的任何值，则还必须设置阈值参数。 removeEmpty (Boolean) 如果为true，则全部删除由阈值过滤掉的行和列。如果设置此标志，将不使用按行和列进行聚类。 5.3.16 集合可视化 (UpSet) 集合可视化。 UpSet将二进制列（即每行为文字“0”或“1”，“true”或“false”，“yes”或“no”的列）解释为集合。 sets选项中的任何字段都将以这种方式解释。 由于大多数数据未按照二进制列形式排列，因此可视化还通过“fields”选项支持任意类别的字段。 此列表中指定的每个字段将首先被预处理为0/1列的集合，然后将其传递给UpSet。 例如，假设数据表为： [ {&quot;id&quot;: &quot;n1&quot;, &quot;f1&quot;: 1, &quot;f2&quot;: &quot;x&quot;}, {&quot;id&quot;: &quot;n2&quot;, &quot;f1&quot;: 0, &quot;f2&quot;: &quot;x&quot;}, {&quot;id&quot;: &quot;n3&quot;, &quot;f1&quot;: 0, &quot;f2&quot;: &quot;y&quot;} ] 您可以使用以下选项创建UpSet可视化文件： new UpSet({ data: data, id: &#39;id&#39;, sets: [&#39;f1&#39;], fields: [&#39;f2&#39;] }); 如下所示，这会将f2字段预处理为f2 x和f2 y集合，并使它们可用于UpSet： [ {&quot;id&quot;: &quot;n1&quot;, &quot;f1&quot;: 1, &quot;f2 x&quot;: 1, &quot;f2 y&quot;: 0}, {&quot;id&quot;: &quot;n2&quot;, &quot;f1&quot;: 0, &quot;f2 x&quot;: 1, &quot;f2 y&quot;: 0}, {&quot;id&quot;: &quot;n3&quot;, &quot;f1&quot;: 0, &quot;f2 x&quot;: 0, &quot;f2 y&quot;: 1} ] 该组件可以在插件candela/plugins/upset包中找到。 5.3.16.1 可选参数 data (Table) 数据表。 id（String） 包含每个记录的唯一标识符的字段。 fields (Array of String) 将在UpSet视图中显示的字段列表。 每个字段中的值在传递给UpSet之前都将转换为设置的0/1字段。 sets (Array of String) 将在UpSet视图中显示的字段列表。 假定每个字段已经是0/1集字段。 metadata (Array of String) 向下钻取单个记录时将显示为元数据的字段列表。数字数据还将显示在每组右侧的摘要框图中。 5.4 API文件 5.4.1 Candela JavaScript API candela.components – Candela内置组件。 Sizing Field matchings Data types Visualization components –Candela组件基类。 candela.mixins – Candela内置组件Mixin。 Utilities – Candela实用功能。 5.4.1.1 组件 Candela随附了几个可立即使用的可视化组件。为了使这些组件更容易地包含在您的项目中，它们被分为几个内置插件。每个插件通过其index.js文件导出其内容： import * as candelaVega from &#39;candela/plugins/vega&#39;; let vis = new candelaVega.BarChart(...); 并可以通过其load.js文件将其内容加载到candela.components对象，如下所示： import candela from &#39;candela&#39;; import &#39;candela/plugins/vega/load.js&#39;; let vis = new candela.components.BarChart(...); 您也可以直接导入组件： import BarChart from &#39;candela/plugins/vega/BarChart&#39;; let vis = new BarChart(...); 最后，您还可以导入candela捆绑包，该捆绑包的构建是为了包含每个预装到candela.components中的组件： import candela from &#39;candela/dist/candela&#39;; let vis = new candela.components.BarChart(...); 但是candela捆绑包非常大。使用其他方法之一构建应用程序将产生一个更小，更易于管理的大小的捆绑包。 当前的插件列表是： candela/plugins/vega – 基于Vega的图表，包括基本图表类型，例如条形图，散点图和直方图。 candela/plugins/geojs – 基于GeoJS的组件用于地理空间数据可视化。 candela/plugins/glo – 基于GLO的组件-“图形级操作”。 candela/plugins/lineup – 基于LineUp的组件，用于可视化排序。 candela/plugins/onset – 基于OnSet的组件，用于可视化子集关系。 candela/plugins/sententree - 基于SentenTree的组件，用于可视化文本语料库的语法结构。 candela/plugins/similaritygraph – 一种专用的交互式图形可视化组件，用于调查数据表中节点之间的相似度。 candela/plugins/trackerdash – 基于TrackerDash算法指标跟踪仪表板的组件。 candela/plugins/treeheatmap – 一个结合了层次聚类的热图。 candela/plugins/upset – 基于UpSet的组件，也用于可视化子集关系。 有关每个组件的更多详细信息（包括如何将这些捆绑包导入到项目中），请参阅组件文档的完整列表。 5.4.1.2 尺寸调整 组件通常具有’width’和’height’选项，该选项以像素为单位指定组件的宽度和高度。 5.4.1.3 变量 5.4.1.3.1 坐标轴刻度 几个组件具有与可视化轴相关的选项。这些通常称为x和y，但也可能具有更描述性的名称。该组件通常会自动检测要映射到轴的字段中的值的类型，并会创建适当的轴类型，例如字符串字段的均等值和数字字段和日期字段的连续范围轴。显示连续范围的轴的可视化通常允许通过在可视化区域中拖动和滚动来平移和缩放轴。 The component will often automatically detect the type of values in the field being mapped to an axis and will create an appropriate axis type, such as evenly-spaced values for string fields and a continuous-ranged axis for numeric and date fields. 5.4.1.3.2 色标 许多Candela组件包含一个color选项，该选项将通过指定的变量为可视元素着色。在可能的情况下，颜色将检测列的数据类型并使用适当的色标。对于包含字符串/文本值的字段，可视化将为每个唯一数值使用具有不同颜色的色标。对于包含数字或日期值的变量，可视化将使用从低到高的平滑颜色渐变。 5.4.1.4 资料类型 5.4.1.4.1 表格 Candela表是以下形式的记录的数组： [ { &quot;a&quot;: 1, &quot;b&quot;: &quot;Mark&quot;, &quot;c&quot;: &quot;Jun 1, 2010&quot; }, { &quot;a&quot;: 2, &quot;b&quot;: &quot;Andy&quot;, &quot;c&quot;: &quot;Feb 6, 2010&quot; }, { &quot;a&quot;: 3, &quot;b&quot;: &quot;Joe&quot;, &quot;c&quot;: &quot;Nov 27, 2010&quot; } ] 5.4.1.4.2 可视化组件 VisComponent是Candela可视化组件的基类。此类是故意最小的，因为所有Candela组件只有几个共同的特征： Candela组件可在网络上运行，因此构造函数为new VisComponent(el)，其中el（通常情况下）是DOM元素。 VisComponent构造函数将el附加到对象上，因此您始终可以使用this.el对其进行引用。 Candela组件都会执行某种类型的可视化，因此它们具有各自的生成（render）函数。基类生成函数只会抛出异常。 有时您需要在运行时更改可视化的某个方面，例如颜色图、哪些数据列正在背可视化、甚至是数据本身。为了支持此类更改，Candela组件提供了一种更新方法。基类更新返回一个promise对象，该对象将交付组件本身。 当可视化组件的生命周期即将结束时，可能需要对其进行清理，这可以通过组件的destroy函数来完成。基类destroy只是从this.el中删除其所有内容。您可以通过扩展VisComponent来创建一个具体的可视化组件。 以下最佳做法可最大程度地提高组件的清晰度，可重用性和互操作性（在本文档的其余部分中，假设Component被声明为VisComponent的扩展，例如BarChart）： 构造函数应该使用额外的一个参数选项来封装该组件所有的运行时选项。 组件应在Component.options中报告其预期的输入参数。 var component = new Component(el, options) 构造Candela组件的新实例。 el是用于可视化的有效容器。容器通常是DOM元素，例如 ，但对于某些可视化可能需要另一种容器类型。 options是一个对象，其中包含可视化的初始选项。这包括任何与可视化相关的数据，视觉匹配或其他设置。选项以{name：value}的形式指定。 注意：抽象超类的构造函数为空。您应该将构造函数用于VisComponent的特定子类。 component.render() 使用当前选项集将组件渲染到其容器中。 注意： VisComponent的render()方法只会抛出一个异常。 如果您确实希望组件在渲染时不执行任何操作，只需将方法重新定义为无操作即可。 component.update(options) 更改组件状态以反映选项。此方法允许对组件状态进行增量更改。选项的格式应与构造函数采用的格式相同。区别在于，只有被传输入此函数的参数会被更改，而任何未指定的参数应保持不变。 注意：VisComponent的update()函数返回一个promise对象。 因为每个组件的更新语义都不同，该对象将交付组件本身而不会更改组件。 component.destroy() 当不再需要该组件时，执行任何所需的清理。这可能只是简单的清空组件一直在使用的容器元素，也可能涉及取消注册事件侦听器等。 注意：VisComponent的destroy()函数只是清空顶层容器，因为这是最常见的清空操作。 component.empty() 清空组件容器元素的便捷方法。这可以在构造函数中用于准备容器元素，也可以在destroy函数中用于在组件之后进行清理。 component.serializationFormats serializationFormats参数是受支持格式的字符串列表。格式包括： ‘png’：PNG图片的base64编码的字符串。可以将字符串放在元素的src属性中以显示图像。 ‘svg’：SVG场景的base64编码的字符串。可以将字符串放在元素的src属性中以显示图像。 component.serialize(format) 将组件序列化为指定的格式。 Component.options 此静态属性是Option规范的数组(array)，其中包含此可视化接受的参数的描述。可以用于自检组件以实现诸如自动UI构建之类的功能。 Component.container 包含此可视化可以添加到的容器类型的静态字段。最常见的是DOMElement。 5.4.1.4.3 Mixins VisComponent在创建新组件时，Candela使用mixins向其添加功能。要使用mixin，模式如下： class MyCoolVisualization extends Mixin(candela.VisComponent) { . . . } Mixin使用以下模式定义: const Mixin = Base =&gt; class extends Base { mixinMethod() { . . . } }; 这是一个将基本类映射到新的未命名类的函数表达式。 换句话说，mixin是可以应用于VisComponent（或任何现有组件类）的函数，以产生具有附加功能的新类。 Candela自带有几个mixin，可在插件candela/plugins/mixin中找到。 Events() 向组件添加基本事件处理。该组件获得一个.on()函数和一个事件类型，该函数使用一个命名事件类型的字符串、在事件发生时调用的回调函数、以及一个使用事件类型和可选参数的.trigger()函数来触发该类事件。 InitSize() 根据实例化组件时this.el的大小，将width和height属性写入组件。 Resize() 每当包含元素的大小更改时，使用Events mixin来触发调整大小(resize)事件。 该事件使用元素的新宽度、高度、和组件的reference触发。 AutoResize() 合并了InitSize和Resize mixin的功能，并通过更新this.width和this.height属性自动响应resize事件。 VegaView() 实现Vega或Vega-Lite可视化组件。子类需要实现generateSpec()函数。generateSpec()函数根据视图选项返回适当的Vega / Vega-Lite Specification。 5.4.1.5 选项详述 选项详述将可视化的输入描述为Component.options数组(array)的一部分 。它是一个包含以下属性的对象： name (String) 选项的名称。 type (String) 选项的类型。类型和格式遵循 Girder Worker类型/格式。 format (String) 选项的格式（类型中的特定编码）。类型和格式遵循 Girder Worker类型/格式。 domain (Domain) 可选；限制选项的允许值集。 5.4.1.6 域详述 选项的域限制了选项的允许值集。它是具有以下属性的对象： mode (String) 域模式，‘choice’或’field’之一。 ’choice’模式将允许在“from”参数设置一组固定的选项集。 ’field’模式将允许来自另一个输入的单个变量或变量列表。如果选项类型为’string’，则选项为单个变量；如果选项类型为’ string_list’，则选项接受变量列表。 from (Array 或 String) 如果模式是’choice’，则它是用作下拉列表的字符串数组。如果模式为’field’，则为要从中提取变量的输入的名称。 fieldTypes (Array) 如果模式是’field’, 则指定支持的参数类型。此数组可以包含datalib支持的变量类型的任意组合，包括’string’，‘date’，‘number’，‘integer’，和 ‘boolean’。 5.4.1.7 实用工具 Candela 实用函数。 &gt; util.getElementSize(el) 返回一个对象，该对象的width和height包含以像素为单位的DOM元素el的当前宽度和高度。 util.vega 5.4.1.7.1 用于生成Vega规范的实用工具 util.vega.chart(template, el, options, done) 根据带有选项的实例化模板生成Vega图表。 template是代表图表的Vega模版。 el是放置Vega可视化文件的DOM元素。 options是{key：value} pair的对象，包含在编译模板时使用的选项。选项可以包含任意嵌套的对象和数组。 done是在生成Vega图表时调用的回调函数。该函数采用一个参数–即生成的Vega图表。 util.vega.transform(template, options) 返回具有已给选项的模板实例。这是js：funcʻutil.vega.chart`使用的基础函数，用于在使用Vega库渲染之前实例化其模板。 template是Vega模板。 options是{key：value}pair的对象，包含在编译模板时使用的选项。选项可以包含任意嵌套的对象和数组。 5.4.2 Candela Python API Candela Python代码库允许在Jupyter Notebook中使用交互式Candela可视化效果。 candela.components.ComponentName(**options) 根据已给可选变量创建一个代表Candela可视化效果的对象。ComponentName是Candela组件的名称，例如ScatterPlot。有关组件及其选项的完整列表，请参见组件。 如果将pandas DataFrame作为可选参数传入函数，在将其发送到Candela可视化组件之前，它将被自动转换为以下格式的记录列表： [{“a”: 1, “b”: “foo”}, {“a”: 2, “b”: “baz”}]。 要显示组件，只需简单的将可视化（不需要将其分配给其他变量）作为Notebook单元格中的最后一条语句即可。您还可以使用vis.display()来从单元格中的任意位置显示可视化效果。 5.4.3 Candela R API Candela R代码库通过将Candela转为htmlwidgets来启用R Studio中的交互式Candela可视化效果。 candela(name, …) 创建一个代表定选项指定的Candela可视化效果的小部件。name是Candela组件的名称，例如“ScatterPlot”。有关组件及其选项的完整列表，请参见组件。 Creates a widget representing the Candela visualization specified by the given options. 如果将data frame作为可选变量传入函数，在将其发送到Candela可视化组件之前，它将被自动转换为以下格式的记录列表： [{“a”: 1, “b”: “foo”}, {“a”: 2, “b”: “baz”}]。 5.5 开发人员文件 5.5.1 编码规范指南 我们所有JavaScript代码都遵循JavaScript Semistandard编码规范。 5.5.2 创建Candela代码发布 要执行Candela的新版本发布，请按照以下步骤操作。假设master上的代码已准备好转换为新版本（即，它已通过所有测试并包含新版本所需的所有新功能）。在此示例中，我们将模拟新发行版的版本号为1.2.0。 创建一个新的发行分支，名为release-1.2.0： git checkout -b release-1.2.0 master 通过编辑package.json将版本号提升到1.2.0。使用提交消息“ 提升版本号以发布”进行提交，然后推送分支： vim package.json git commit -am &#39;提升版本号以发布&#39; git push -u origin release-1.2.0 新建一个本地分支以将您的位置保存在此处的提交树中。请确保您的checkout仍为1.2.0版。您可以执行以下操作： git branch save-point 使用“production” NPM脚本构建分发文件： npm run build:production 这将会创建一个dist目录，其中包含两个JavaScript文件（普通版和精简版）。 提交production文件，然后再次推送。 git add dist git commit -m &#39;添加production文件以发布&#39; git push 从release-1.2.0分支创建代码合并请求。请确保将请求的基础分支定为release分支，而不是master分支。 等待“LGTM”（Looks Good To Me）确认信息，然后合并拉取请求并删除release-1.2.0分支。 检出release分支，拉取，标记发布，推送，然后删除release-1.2.0分支。 git checkout release git pull git tag v1.2.0 git push --tags git branch -d release-1.2.0 将新程序包发布到NPM, 您将需要首先使用NPM凭据登录。 npm login npm publish 将保存点分支合并到master中（请勿使用快进合并（fast-forward merge）。因为这是一种特殊的提交类型，它会准备master分支使用新的版本号的下一次开发，而不是添加新功能）。 其次推送，然后删除savepoint。请确保您没有合并release-1.2或release到master中；我们不希望distribution files合并进主线开发分支。 git checkout master git merge save-point git branch -d save-point git push 发行过程到此结束。您发布了一个带有标签的新发行版，并在发行分支上进行了相应的提交， 而master会更新软件包的版本号，以备进一步开发。 5.5.3 测试 5.5.3.1 图像测试 Candela的测试阶段之一就是图像测试：可视化组件的图像会以编程的方式被生成，和基准图像进行比较。 图像会自动上传到Kitware’s Girder 实例，通过Travis构建编号（build number）分类，可以被所有人查看。 "],["greek-translation-of-edav-infohisto.html", "Chapter 6 Greek translation of edav.info/histo 6.1 Διάγραμμα: Ιστόγραμμα 6.2 Επισκόπηση 6.3 Σύνοψη 6.4 Simple examples 6.5 Θεωρία 6.6 Τύποι ιστογραμμάτων 6.7 Παράμετροι 6.8 Διαδραστικά ιστογράμματα με το ggvis 6.9 Εξωτερικές πηγές", " Chapter 6 Greek translation of edav.info/histo Kassiani Papasotiriou 6.1 Διάγραμμα: Ιστόγραμμα 6.2 Επισκόπηση Αυτή η ενότητα καλύπτει τον τρόπο δημιουργίας ιστογραμμάτων. 6.3 Σύνοψη Δώσε μου ένα πλήρες παράδειγμα! Ορίστε μια εφαρμογή ιστογραμμάτων που εξετάζει το πώς άλλαξαν τα ράμφη των σπίνων των Νησιών Γκαλαπάγκος λόγω εξωτερικών παραγόντων: Και εδώ είναι ο κώδικας: library(Sleuth3) # data library(ggplot2) # plotting # load data finches &lt;- Sleuth3::case0201 # finch histograms by year with overlayed density curves ggplot(finches, aes(x = Depth, y = ..density..)) + # plotting geom_histogram(bins = 20, colour = &quot;#80593D&quot;, fill = &quot;#9FC29F&quot;, boundary = 0) + geom_density(color = &quot;#3D6480&quot;) + facet_wrap(~Year) + # formatting ggtitle(&quot;Μεγάλη Ξηρασία Οδήγησε σε Σπίνους με Μεγαλύτερα Ράμφη&quot;, subtitle = &quot;Πυκνότητα Βάθους Ραμφών των Σπίνων των Γκαλαπάγκος ανά Έτος&quot;) + labs(x = &quot;Βάθος Ράμφους (mm)&quot;, caption = &quot;Source: Sleuth3::case0201&quot;) + theme(plot.title = element_text(face = &quot;bold&quot;)) + theme(plot.subtitle = element_text(face = &quot;bold&quot;, color = &quot;grey35&quot;)) + theme(plot.caption = element_text(color = &quot;grey68&quot;)) Για περισσότερες πληροφορίες σχετικά με αυτό το σύνολο δεδομένων, γράψτε ?Sleuth3::case0201 στην κονσόλα. 6.4 Simple examples Έη, όπα, στάσου! Πολύ απλούστερο παρακαλώ! Ας χρησιμοποιήσουμε ένα πολύ απλό σύνολο δεδομένων: # store data x &lt;- c(50, 51, 53, 55, 56, 60, 65, 65, 68) 6.4.1 Ιστόγραμμα με χρήση βασικής R # plot data hist(x, col = &quot;lightblue&quot;, main = &quot;Ιστόγραμμα βασικής R για το x&quot;) Το πλεονέκτημα του ιστογράμματος βασικής R είναι πως μπορεί να ρυθμιστεί εύκολα. Στην πραγματικότητα, το μόνο που χρειάζεσαι για να απεικονίσεις γραφικά τα συγκεκριμένα δεδομένα x είναι η hist(x), αλλά συμπεριλάβαμε λίγο χρώμα και έναν τίτλο ώστε να τα κάνουμε πιο ευπαρουσίαστα. Πλήρης τεκμηρίωση σχετικά με τη hist() μπορεί να βρεθεί εδώ 6.4.2 Ιστόγραμμα με χρήση ggplot2 # import ggplot library(ggplot2) # must store data as dataframe df &lt;- data.frame(x) # plot data ggplot(df, aes(x)) + geom_histogram(color = &quot;grey&quot;, fill = &quot;lightBlue&quot;, binwidth = 5, center = 52.5) + ggtitle(&quot;Ιστόγραμμα ggplot2 για το x&quot;) Η εκδοχή με ggplot είναι λίγο πιο περίπλοκη φαινομενικά, αλλά ως αποτέλεσμα παίρνεις μεγαλύτερη ισχύ και έλεγχο. Σημείωση: Όπως φαίνεται παραπάνω, η ggplot αναμένει ένα πλαίσιο δεδομένων, οπότε εάν λαμβάνεις ένα σφάλμα όπου “η R δεν ξέρει τι να κάνει” όπως αυτό: ggplot dataframe error βεβαιώσου πως χρησιμοποιείς ένα πλαίσιο δεδομένων. 6.5 Θεωρία Σε γενικές γραμμές, το ιστόγραμμα είναι μία από πολλές επιλογές για την προβολή συνεχών δεδομένων. Το ιστόγραμμα μπορεί να δημιουργηθεί εύκολα και γρήγορα. Τα ιστογράμματα είναι λίγο πολύ αυτονόητα: δείχνουν την εμπειρική κατανομή των δεδομένων σου σε ένα σύνολο διαστημάτων. Τα ιστογράμματα μπορούν να χρησιμοποιηθούν σε ανεπεξέργαστα δεδομένα για να δείξουν γρήγορα την κατανομή χωρίς πολλούς χειρισμούς. Χρησιμοποίησε ένα ιστόγραμμα για να πάρεις μια βασική αίσθηση της κατανομής έχοντας ελάχιστες απαιτήσεις για επεξεργασία. • Για περισσότερες πληροφορίες σχετικά με τα ιστογράμματα και τις συνεχείς μεταβλητές, δες το Κεφάλαιο 3 του βιβλίου. 6.6 Τύποι ιστογραμμάτων Χρησιμοποίησε ένα ιστόγραμμα για να δείξεις την κατανομή μιας συνεχούς μεταβλητής. Η κλίμακα του άξονα y μπορεί να αναπαρασταθεί με διάφορους τρόπους για να εκφράσει διαφορετικά αποτελέσματα: 6.6.1 Συχνότητα ή μέτρηση y = αριθμός τιμών που υπάγονται στην κάθε ζώνη 6.6.2 Ιστόγραμμα σχετικής συχνότητας y = αριθμός τιμών που υπάγονται στην κάθε ζώνη / συνολικός αριθμός τιμών 6.6.3 Ιστόγραμμα συνολικής συχνότητας y = συνολικός αριθμός τιμών &lt;= (ή &lt;) του άνω ορίου της ζώνης 6.6.4 Πυκνότητα y = σχετική συχνότητα / εύρος ζώνης 6.7 Παράμετροι 6.7.1 Όρια ζωνών Σκέψου τα όρια των ζωνών και εάν ένα σημείο θα πέσει στην αριστερή ή τη δεξιά ζώνη όταν βρίσκεται πάνω στο όριο. # format layout op &lt;- par(mfrow = c(1, 2), las = 1) # right closed hist(x, col = &quot;lightblue&quot;, ylim = c(0, 4), xlab = &quot;δεξί κλειστό (55, 60]&quot;, font.lab = 2) # right open hist(x, col = &quot;lightblue&quot;, right = FALSE, ylim = c(0, 4), xlab = &quot;δεξί ανοιχτό [55, 60)&quot;, font.lab = 2) 6.7.2 Αριθμός ζωνών Ο προεπιλεγμένος αριθμός των 30 ζωνών στη ggplot2 δεν είναι πάντα ιδανικός, οπότε σκέψου να τον αλλάξεις εάν τα πράγματα φαίνονται περίεργα. Μπορείς να καθορίσεις το εύρος ρητά με το binwidth ή να δώσεις τον επιθυμητό αριθμό ζωνών με το bins. # default...note the pop-up about default bin number ggplot(finches, aes(x = Depth)) + geom_histogram() + ggtitle(&quot;Προεπιλογή με αναδυόμενο παράθυρο για τον αριθμό ζωνών&quot;) Ακολουθούν παραδείγματα αλλαγής των ζωνών με χρήση των δύο τρόπων που περιγράφηκαν παραπάνω: # using binwidth p1 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(binwidth = 0.5, boundary = 6) + ggtitle(&quot;Αλλάχθηκε η τιμή του binwidth&quot;) # using bins p2 &lt;- ggplot(finches, aes(x = Depth)) + geom_histogram(bins = 48, boundary = 6) + ggtitle(&quot;Αλλάχθηκε η τιμή του bins&quot;) # format plot layout library(gridExtra) grid.arrange(p1, p2, ncol = 2) 6.7.3 Ευθυγράμμιση ζωνών Βεβαιώσου ότι οι άξονες αντικατοπτρίζουν τα πραγματικά όρια του ιστογράμματος. Μπορείς να χρησιμοποιήσεις το boundary για να προσδιορίσεις το τέλος οποιασδήποτε ζώνης ή το center για να προσδιορίσεις το κέντρο οποιασδήποτε ζώνης. Η ggplot2 θα μπορέσει να υπολογίσει πού να τοποθετήσει τις υπόλοιπες ζώνες. (Επίσης, παρατήρησε πως όταν το όριο άλλαξε, ο αριθμός των ζωνών μειώθηκε κατά μία. Αυτό συμβαίνει επειδή ως προεπιλογή οι ζώνες είναι κεντραρισμένες και υπερκαλύπτουν (πιο κάτω/ παραπάνω) το εύρος των δεδομένων.) df &lt;- data.frame(x) # default alignment ggplot(df, aes(x)) + geom_histogram(binwidth = 5, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Προεπιλεγμένη Ευθυγράμμιση Ζωνών&quot;) # specify alignment with boundary p3 &lt;- ggplot(df, aes(x)) + geom_histogram(binwidth = 5, boundary = 60, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Ευθ. Ζωνών με χρήση ορίων&quot;) # specify alignment with center p4 &lt;- ggplot(df, aes(x)) + geom_histogram(binwidth = 5, center = 67.5, fill = &quot;lightBlue&quot;, col = &quot;black&quot;) + ggtitle(&quot;Ευθ. Ζωνών με χρήση κέντρου&quot;) # format layout library(gridExtra) grid.arrange(p3, p4, ncol = 2) Σημείωση: Μη χρησιμοποιείς και το boundary και το center για ευθυγράμμιση των ζωνών. Διάλεξε μόνο το ένα. 6.8 Διαδραστικά ιστογράμματα με το ggvis To πακέτο ggvis δεν βρίσκεται σε εξέλιξη επί του παρόντος, αλλά κάνει ορισμένα πράγματα πολύ καλά, όπως η ενεργή προσαρμογή των παραμέτρων ενός ιστογράμματος κατά την συγγραφή του κώδικα. Από τη στιγμή που οι εικόνες δε μπορούν να μοιραστούν με knitting (όπως συμβαίνει με άλλα πακέτα, όπως το plotly), παρουσιάζουμε εδώ τον κώδικα, αλλά όχι την έξοδο. Για να τα δοκιμάσεις, αντίγραψε και επικόλλησε σε μια συνεδρία R. 6.8.1 Διαδραστική αλλαγή του εύρου ζώνης library(tidyverse) library(ggvis) faithful %&gt;% ggvis(~eruptions) %&gt;% layer_histograms(fill := &quot;lightblue&quot;, width = input_slider(0.1, 2, value = .1, step = .1, label = &quot;width&quot;)) 6.8.2 Παράδειγμα ΑΕΠ df &lt;-read.csv(&quot;countries2012.csv&quot;) df %&gt;% ggvis(~GDP) %&gt;% layer_histograms(fill := &quot;green&quot;, width = input_slider(500, 10000, value = 5000, step = 500, label = &quot;width&quot;)) 6.8.3 Διαδραστική αλλαγή κέντρου df &lt;- data.frame(x = c(50, 51, 53, 55, 56, 60, 65, 65, 68)) df %&gt;% ggvis(~x) %&gt;% layer_histograms(fill := &quot;red&quot;, width = input_slider(1, 10, value = 5, step = 1, label = &quot;width&quot;), center = input_slider(50, 55, value = 52.5, step = .5, label = &quot;center&quot;)) 6.8.4 Αλλαγή κέντρου (με τις τιμές δεδομένων που εμφανίζονται) df &lt;- data.frame(x = c(50, 51, 53, 55, 56, 60, 65, 65, 68), y = c(.5, .5, .5, .5, .5, .5, .5, 1.5, .5)) df %&gt;% ggvis(~x, ~y) %&gt;% layer_histograms(fill := &quot;lightcyan&quot;, width = 5, center = input_slider(45, 55, value = 45, step = 1, label = &quot;center&quot;)) %&gt;% layer_points(fill := &quot;blue&quot;, size := 200) %&gt;% add_axis(&quot;x&quot;, properties = axis_props(labels = list(fontSize = 20))) %&gt;% scale_numeric(&quot;x&quot;, domain = c(46, 72)) %&gt;% add_axis(&quot;y&quot;, values = 0:3, properties = axis_props(labels = list(fontSize = 20))) 6.8.5 Διαδραστική αλλαγή ορίου df %&gt;% ggvis(~x) %&gt;% layer_histograms(fill := &quot;red&quot;, width = input_slider(1, 10, value = 5, step = 1, label = &quot;width&quot;), boundary = input_slider(47.5, 50, value = 50, step = .5, label = &quot;boundary&quot;)) 6.9 Εξωτερικές πηγές Τεκμηρίωση του hist: Σελίδα τεκμηρίωσης ιστογράμματος της βασικής R. Σκονάκι της ggplot2: Πάντα καλό να το έχεις παραδίπλα. "],["tableau-intro-tutorial-explained-with-proset2.html", "Chapter 7 Tableau intro tutorial explained with proset2", " Chapter 7 Tableau intro tutorial explained with proset2 Yue Wang For the community contribution project, I will briefly introduce Tableau, the major features of this product, and other relevant products that are used in a different setting. I will introduce structure of the interfaces, importation of data, the supported files of data, supported data types, how to build worksheets and an interactive dashboard. I’ll use the Problem1 from Problem Set 2 to do the demo. This problem includes recoding of factor levels, vertical/horizontal bar chart, and horizontal bar chart of proportion. Although it only covers bar chart, I believe this will be a great first step to learn about how Tableau generally works. After doing the demo, I’ll draw a comparison with R and Excel and reemphasize the context of using Tableau. You can check the video through this link: https://www.bilibili.com/video/BV1py4y167YF/ "],["github-initial-setup.html", "Chapter 8 Github Initial Setup", " Chapter 8 Github Initial Setup Create a repo called “CC20” by following the instructions written in the bookdown-template. In index.Rmd, edit the title, github-repo and add description. In _bookdown.yml, edit relevant github information. In index.Rmd, include “Chapter 1: Instructions” similar to CC19. Add “Chapter 2: The Sample Project” by creating sample_project.Rmd. In _bookdown.yml, define our own order of Rmd files for the book in a field named rmd_files. Without rmd_files, the table of content of the book would be ordered alphabetically by the title of each Rmd file. Please read bookdown Usage for further reference. "]]
